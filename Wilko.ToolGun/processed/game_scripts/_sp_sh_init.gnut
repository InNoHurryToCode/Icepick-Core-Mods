untyped

global function SPMP_Shared_Init
#if DEV && SERVER
global function LeveledWeaponDump
#endif

// TOOLGUN START
global function printc
global bool printc_running
global const bool TOOLGUN_ENABLE_MOUSE_ROTATE = false

#if CLIENT
global function Toolgun_Client_PrimaryAttack
#endif
// TOOLGUN END

// CUSTOM GAUNTLET START
#if CLIENT
global function ServerCallback_Gauntlet_StartRun
global function ServerCallback_Gauntlet_FinishRun
#endif
// CUSTOM GAUNTLET END

void function SPMP_Shared_Init()
{
//	Settings_Init()
	GAMETYPE = "solo"

	Shared_SP_Init()
	Toolgun_Shared_Init()
}

void function Shared_SP_Init()
{
	ShCommonModels_Init()
	Utility_Shared_Init()
	CodeCallbacksShared_Init()
	Flags_Init()
	RemoteFunctions_Init()
	DamageTypes_Init()
	WeaponUtility_Init()
	PassivesShared_Init()
	ShUtilityAll_Init()
	Anim_Aliases_Init()
	MinimapShared_Init()
	NetworkMarkerShared_Init()
	PlayerLeechingShared_Init()
	InitWeaponScripts()
	Death_Package_Init()
	TitanSoul_Init()
	TitanShared_Init()
	TitanFastball_Init()
	Highlight_Init()
	FlightpathShared_Init()
	StimShared_Init()
	Crane_Init()
	MobilityGhost_Init()
	SPObjectiveInit()
	SPObjectiveStringsInit()
	SPDialogueInit()
	DialogueShared_Init()
	SonarShared_Init()
	TitanEmbark_Init()
	IonEnergy_Init()

	if ( IsTestMap() )
		PrecacheSPWeapons()

#if DEV
	PrecacheWeapon( "weapon_cubemap" )
#endif
	DeathHints_Init()

	ProtoBatteryCharger_Init()

	ShAIBossTitan_Init()
	Sh_EarnMeter_Init()
	RemoteTurrets_Init()

	Gauntlet_SharedInit()
	ShTitanOSConversations_Init()
	OnscreenHints_Init()

	#if SERVER
	Server_SP_Init()
	#elseif CLIENT
	Client_SP_Init()
	#endif
}

#if SERVER
void function Server_SP_Init()
{
	CodeCallback_Init()
	AddCallback_EntitiesDidLoad( ShSp_EntitiesDidLoad )
	Utility_Init()
	#if DEV
	AutoPrecache_Init()
	#endif
	Anim_Init()
	Viewcone_Init()
	UIVars_Init()
//	MenuCallbacks_Init()
	TitanTransfer_Init()
	TitanNPC_Init()
	TitanNpcBehavior_Init()
	ToneController_Init()
	DropPodFireteam_Init()
	Objective_Init()

	StartPoint_Init()

	GruntChatter_Init()
	Gauntlet_ServerInit()
	PainDeathSounds_Init()

	SPDifficulty_Init()
	SPUtility_Init()
	SpInitLoadouts()
	Pickups_Init()
	PickupAmmo_Init()
	ArcConnectors_Init()
	InfiniteSpawners_Init()
	ReplacementTitans_Init()

	BaseGametype_Init()
	RiffSettings_Init()
	AiUtility_Init()
	InitSharedStartPoints()

	GameState_Init()

	Music_Init()

	TitanTether_Init()

	AiSoldiers_Init()
	AiSpawn_Init()

	AiPilots_Init()
	AiDrone_Init()
	AiSpectre_Init()
	AiStalker_Init()
	AiSuperspectre_Init()
	AiGunship_Init()
	SuicideSpectres_Init()
	AiMarvins_Init()
	ControlPanel_Init()
	//AiTurret_Init()
	AiTurretSentry_Init()
	SpectreRack_Init()
	LoadoutCrate_Init()
	TitanCommands_Init()
	//#if DEVSCRIPTS
	//MortarTitans_Init()
	//#endif

	ClassTitan_Init()
	ClassWallrun_Init()

	HealthRegen_Init()
	EmpTitans_Init()

	PlayerCloak_Init()
	ParticleWall_Init()
	Smokescreen_Init()

	ScriptMovers_Init()

	TitanHotdrop_Init()

	Zipline_Init()
	Passives_Init()

	Leeching_Init()
	PlayerLeeching_Init()

	TitanHealth_Init()

	ChargeBall_Precache()

	MarvinJobs_Init()
	MarvinFaces_Init()
	TriggerFunctions_Init()
	TriggerFunctionsSP_Init()
	SpawnFunctions_Init()
	GoblinDropship_Init()

	FriendlyFollowerInit()
	SPDropship_Init()

	Melee_Init()
	Rodeo_Init()
	AiPersonalShield()

	SpShWeaponsInit()
	GamemodeSp_Init()

	ATTurrets_Init()
	AIBossTitan_Init()

	SniperSpectres_Init()
	CloakDrone_Init()
	InitCombatPaths()
	InitSaveGame()

	Sv_EarnMeter_Init()
	Sv_EarnMeterSP_Init()

	TitanHints_Init()
	InitDestroyableGenerator()

	SP_IntroScreen_Init()

	SP_TitanWeaponPickups_Init()
}

void function ShSp_EntitiesDidLoad()
{
	LeveledScriptedWeapons leveledScriptedWeapons = GetAllLeveledScriptWeapons()

	// we have to spawn the weapons manually because spawn callbacks for pre-placed entities have already passed
	foreach ( ent in leveledScriptedWeapons.infoTargets )
	{
		CreateScriptWeapon( ent )
	}

	// add spawn callbacks in case anybody is spawning from a spawner. Could happen.
	foreach ( weaponName, _ in leveledScriptedWeapons.foundScriptWeapons )
	{
		AddSpawnCallbackEditorClass( "info_target", weaponName, CreateScriptWeapon )
	}
}
#endif // SERVER

#if CLIENT
void function Client_SP_Init()
{
	ClAutoPrecache_Init()
	ClMelee_Init()
	CLUtilityMenu_Init()
	CLAnnouncement_Init()
	CLEventNotification_Init()
	CLUtilitySplash_Init()
	ClientCodeCallbacks_Init()
	ClRodeo_Init()
	RiffSettings_Init()
	SpShWeaponsInit()
	Cl_Sentry_Turrets_Init()
	ClTitanCockpit_Init()
	ClDataKnife_Init()
	CLLoadoutCrate_Init()
	SmartAmmoClient_Init()
	CLGoblinDropship_Init()
	ClIntroscreen_Init()
	ClPlayerADSDofInit()
	ClPlayer_Init()
	ClWeaponFlyout_Init()
	ClDroppedWeaponFlyout_Init()
	ClTitanHud_Init()
	ClTitanCommands_Init()
	ClObjective_Init()
	ClMainHud_Init()
	ClSuicideSpectres_Init()
	ClTripleHealthInit()
	CinematicIntroScreen_Init()
	ClRespawnselect_SP_Init()

	ClGamemodeSp_Init()
	ClSpHud_Init()
	ClWeaponStatus_Init()

	ClScreenfade_Init()

	ClIndicatorsHud_Init()
	ClHealthHud_Init()
	ClScoreboardPrecache_Init()
	ClScoreboard_Init()
	ClScoreboardSp_Init()
	ClReplacementTitanHud_Init()
	ClDialogue_Init()
	ClEntityCreationFunctions_Init()

	ClCrowDropship_Init()
	ClCrowDropshipHero_Init()
	ClDraconis_Init()
	ClGoblinDropship_Init()
	ClGoblinDropshipHero_Init()
	ClPhantomFighter_Init()
	ClWidow_Init()
	ClCrowDropshipXS_Init()

	Cl_EarnMeter_Init()
	CLAIBossTitan_Init()

	ClControlPanel_Init()
	ClSpectre_Init()
	ClStalker_Init()
	ClSuperSpectre_Init()
	ClDrone_Init()
	ClGunship_Init()
	ClAiTurret_Init()
	CL_ToneHUD_Init()
	PerfInitLabels()

	GruntChatter_SharedInit()
	ClTitanHints_Init()

	Gauntlet_ClientInit()

	CL_TitanWeaponPickup_Init()
	ClTitanCockpitSounds_Init()

}
#endif // CLIENT

#if DEV && SERVER
void function LeveledWeaponDump()
{
	DevTextBufferClear()

	printt( "PRINTING WEAPONS" )
	DevTextBufferWrite( "// AUTO GENERATED FILE, DO NOT EDIT.\n\n" )
	array<string> allWeapons = GetAllSPWeapons()
	array<string> weapons
	DisablePrecacheErrors()
	wait 0.5
	foreach ( weaponName in allWeapons )
	{
		PrecacheWeapon( weaponName )
		if ( !GetWeaponInfoFileKeyField_Global( weaponName, "leveled_pickup" ) )
			continue

		weapons.append( weaponName )
	}

	weapons.sort( SortStringAlphabetize )

	var modtable = GetDataTable( $"datatable/pilot_weapon_mods.rpak" )

	foreach ( weaponName in weapons )
	{
		var modelName
		var modelName1 = GetWeaponInfoFileKeyField_Global( weaponName, "droppedmodel" )
		var modelName2 = GetWeaponInfoFileKeyField_Global( weaponName, "playermodel" )
		if ( modelName1 != null )
			modelName = modelName1
		else
			modelName = modelName2

		DevTextBufferWrite( "entityDef " + weaponName + "\n" )
		DevTextBufferWrite( "{\n" )
		DevTextBufferWrite( "	\"editor_var angles\"         \"This entity's orientation in the world. Pitch is rotation around the Y axis, yaw is the rotation around the Z axis, roll is the rotation around the X axis.\"\n" )
		DevTextBufferWrite( "	\"angles\"                    \"0 0 0\"	\n" )
		DevTextBufferWrite( "\n" )
		DevTextBufferWrite( "	\"editor_usage\"              \"A player can pick up this weapon\"	\n" )
		DevTextBufferWrite( "	\"editor_color\"              \"1 1 1\"	\n" )
		DevTextBufferWrite( "	\"editor_mins\"               \"-8 -8 -8\"	\n" )
		DevTextBufferWrite( "	\"editor_maxs\"               \"8 8 8\"	\n" )
		DevTextBufferWrite( "	\"editor_vmf\"                \"1\"	\n" )
		DevTextBufferWrite( "	\"editor_displayFolder\"      \"weapons\"	\n" )
		DevTextBufferWrite( "\n" )
		DevTextBufferWrite( "	\"editor_var script_group\"   \"Extra info for script\"	\n" )
		DevTextBufferWrite( "	\"script_group\"              \"\"	\n" )
		DevTextBufferWrite( "\n" )
		DevTextBufferWrite( "	\"editor_var script_noteworthy\"  \"Extra info for script\"	\n" )
		DevTextBufferWrite( "	\"script_noteworthy\"         \"\"	\n" )
		DevTextBufferWrite( "\n" )
		DevTextBufferWrite( "	\"editor_var script_name\"    \"Script-gettable entity name\"	\n" )
		DevTextBufferWrite( "	\"script_name\"               \"\"	\n" )
		DevTextBufferWrite( "\n" )
		DevTextBufferWrite( "	\"editor_var model\"                     \"" + modelName + "\"	\n" )
		DevTextBufferWrite( "	\"model\"                     \"" + modelName + "\"	\n" )
		DevTextBufferWrite( "\n" )
		DevTextBufferWrite( "	\"editor_var script_weapon\"  \"Name of weapon to be\"	\n" )
		DevTextBufferWrite( "	\"script_weapon\"             \"" + weaponName + "\"	\n" )
		DevTextBufferWrite( "\n" )
		DevTextBufferWrite( "	\"editor_bool start_constrained\" \"Should the weapon spawn constrained?\"	\n" )
		DevTextBufferWrite( "	\"start_constrained\"             \"\"	\n" )
		DevTextBufferWrite( "\n" )

		string allowedMods = "Available Mods: \\n"
		bool hasMods = false
		for ( int i=0; i<GetDatatableRowCount( modtable ); i++ )
		{
			string weapon = GetDataTableString( modtable, i, GetDataTableColumnByName( modtable, "weapon" ) )
			if ( weapon == weaponName )
		 	{
		 		allowedMods += GetDataTableString( modtable, i, GetDataTableColumnByName( modtable, "mod" ) ) + " \\n"
		 		hasMods = true
		 	}
		}

		string modsString = "List of mods to apply (separated by spaces)"
		if ( hasMods )
		{
			modsString += "\\n"
			modsString += allowedMods
		}

		DevTextBufferWrite( "	\"editor_var script_mods\"    \""+modsString+"\"	\n" )
		DevTextBufferWrite( "	\"script_mods\"               \"\"	\n" )
		DevTextBufferWrite( "}\n" )
		DevTextBufferWrite( "\n" )
	}

	string filename

	// Write to the file
	filename = "def/leveled_weapons.def"
	DevP4Checkout( filename )
	DevTextBufferDumpToFile( filename )
	DevP4Add( filename )


	DevTextBufferClear()
	DevTextBufferWrite( "// AUTO GENERATED FILE, DO NOT EDIT.\n\n" )
	foreach ( weaponName in weapons )
	{
		if ( !GetWeaponInfoFileKeyField_Global( weaponName, "leveled_pickup" ) )
			continue

		DevTextBufferWrite( "@PointClass alias(info_target) partition(\"script\") = " + weaponName + " []\n" )
	}

	filename = "../bin/r2_weapons.fgd"
	DevP4Checkout( filename )
	DevTextBufferDumpToFile( filename )
	DevP4Add( filename )

	wait 0.2
	RestorePrecacheErrors()
}
#endif

// -----------------------------------------------------------------------------
// Toolgun
// -----------------------------------------------------------------------------

void function printc( ... )
{
	thread Dump_printc()
	for( int i = 0; i < vargc; i++ )
	{
		DevTextBufferWrite( "" + vargv[i] )
		if( i + 1 < vargc )
		{
			DevTextBufferWrite( "\t" )
		}
	}
}

void function Dump_printc()
{
	WaitFrame()
	DevTextBufferDumpToFile( "../console_log.txt" )
	DevTextBufferClear()
}

const asset SPAWN_MODEL = $"models/imc_base/cargo_container_imc_01_red.mdl"

// const EMP_GRENADE_BEAM_EFFECT = $"wpn_arc_cannon_beam"
const EMP_GRENADE_BEAM_EFFECT = $"P_wpn_charge_tool_beam"
const TOOLGUN_GRAB_EFFECT = $"P_wpn_hand_laser_beam"

array<table> ToolGunTools = [];
array<bool functionref( entity, array<string> )> ToolGunToolFunctions = [];

struct
{
	int CurrentMode,
	int CurrentModeIdx
	asset SelectedModel
} ToolGunSettings;

void function Toolgun_Shared_Init()
{
	PrecacheModel( SPAWN_MODEL )
	PrecacheParticleSystem( EMP_GRENADE_BEAM_EFFECT )
	PrecacheParticleSystem( TOOLGUN_GRAB_EFFECT )

	for (var i = 0; i < SpawnList.len(); i++)
	{
		PrecacheModel( SpawnList[i] );
	}

	Toolgun_RegisterTools()
	#if SERVER
	Toolgun_Server_Init()
	#endif
	#if CLIENT
	Toolgun_Client_Init()
	Toolgun_UI_Init()
	#endif

	CustomGauntlet_Shared_Init()
}

void function Toolgun_RegisterTools()
{
	table ToolSpawnProp = {}
	ToolSpawnProp.id <- "spawn_prop"
	ToolSpawnProp.name <- "Spawn Prop"
	ToolSpawnProp.help <- "Left click to spawn a prop"
	ToolGunTools.append( ToolSpawnProp )
	ToolGunToolFunctions.append( Toolgun_Func_SpawnProp )

	table ToolRemoveProp = {}
	ToolRemoveProp.id <- "remove_prop"
	ToolRemoveProp.name <- "Remove Prop"
	ToolRemoveProp.help <- "Left click to remove a prop"
	ToolGunTools.append( ToolRemoveProp )
	ToolGunToolFunctions.append( Toolgun_Func_RemoveProp )

	table ToolPropInfo = {}
	ToolPropInfo.id <- "prop_info"
	ToolPropInfo.name <- "Prop Info"
	ToolPropInfo.help <- "Left click to print info on a prop to the console"
	ToolGunTools.append( ToolPropInfo )
	ToolGunToolFunctions.append( Toolgun_Func_PropInfo )
}

table function Toolgun_GetCurrentMode()
{
	return ToolGunTools[ ToolGunSettings.CurrentModeIdx ]
}

bool functionref( entity, array<string> ) function Toolgun_GetCurrentModeFunction()
{
	return ToolGunToolFunctions[ ToolGunSettings.CurrentModeIdx ]
}

#if SERVER

struct {
	entity GrabbedEntity,
	vector GrabOffset,
	float GrabDistance,
	bool IsRotating,
	vector LockViewAngle,

	entity GrabBeamEffect,
	entity GrabBeamTarget
} ToolgunGrab;

void function Toolgun_Server_Init()
{
	AddClientCommandCallback( "Toolgun_SetMode", ClientCommand_Toolgun_SetMode )
	AddClientCommandCallback( "Toolgun_PrimaryAttack", ClientCommand_Toolgun_PrimaryAttack )
	AddClientCommandCallback( "Toolgun_GrabEntity", ClientCommand_Toolgun_GrabEntity )
	AddClientCommandCallback( "Toolgun_ReleaseEntity", ClientCommand_Toolgun_ReleaseEntity )
	AddClientCommandCallback( "Toolgun_Grab_StartRotate", ClientCommand_Toolgun_Grab_StartRotate )
	AddClientCommandCallback( "Toolgun_Grab_StopRotate", ClientCommand_Toolgun_Grab_StopRotate )
	AddClientCommandCallback( "Toolgun_Grab_PerformRotation", ClientCommand_Toolgun_Grab_PerformRotation )
	AddClientCommandCallback( "Toolgun_ChangeModel", ClientCommand_Toolgun_ChangeModel )
}

void function Toolgun_Utils_FireToolTracer( entity player )
{
	var lifeDuration = 0.1

	vector eyePosition = player.EyePosition()
	vector viewVector = player.GetViewVector()
	TraceResults traceResult = TraceLine( eyePosition, eyePosition + viewVector * 10000, player, TRACE_MASK_PLAYERSOLID, TRACE_COLLISION_GROUP_PLAYER )

	// Control point sets the end position of the effect
	entity cpEnd = CreateEntity( "info_placement_helper" )
	SetTargetName( cpEnd, UniqueString( "emp_grenade_beam_cpEnd" ) )
	cpEnd.SetOrigin( traceResult.endPos )
	DispatchSpawn( cpEnd )

	vector forward2D = < viewVector.x, viewVector.y, 0 >
	entity zapBeam = CreateEntity( "info_particle_system" )
	zapBeam.kv.cpoint1 = cpEnd.GetTargetName()
	zapBeam.SetValueForEffectNameKey( EMP_GRENADE_BEAM_EFFECT )
	zapBeam.kv.start_active = 0
	zapBeam.SetOrigin( eyePosition + forward2D * 5 )
	DispatchSpawn( zapBeam )

	zapBeam.Fire( "Start" )
	zapBeam.Fire( "StopPlayEndCap", "", lifeDuration )
	zapBeam.Kill_Deprecated_UseDestroyInstead( lifeDuration )
	cpEnd.Kill_Deprecated_UseDestroyInstead( lifeDuration )
}

bool function ClientCommand_Toolgun_SetMode( entity player, array<string> args )
{
	int ToolIdx = args[0].tointeger()
	ToolGunSettings.CurrentModeIdx = ToolIdx
	return true;
}

bool function ClientCommand_Toolgun_PrimaryAttack( entity player, array<string> args )
{
	if( Toolgun_GetCurrentModeFunction() != null )
	{
		Toolgun_GetCurrentModeFunction()( player, args );
		return true
	}
	return false
}

bool function ClientCommand_Toolgun_GrabEntity( entity player, array<string> args )
{
	ToolgunGrab.GrabbedEntity = GetEntByIndex( args[0].tointeger() );
	if( ToolgunGrab.GrabbedEntity != null )
	{
		ToolgunGrab.GrabOffset = Vector( args[1].tofloat(), args[2].tofloat(), args[3].tofloat() );
		ToolgunGrab.GrabDistance = args[4].tofloat();

		/*
		entity cpEnd = CreateEntity( "info_placement_helper" )
		SetTargetName( cpEnd, UniqueString( "emp_grenade_beam_cpEnd" ) )
		cpEnd.SetOrigin( ToolgunGrab.GrabbedEntity.GetOrigin() + ToolgunGrab.GrabOffset )
		DispatchSpawn( cpEnd )
		ToolgunGrab.GrabBeamTarget = cpEnd;

		entity zapBeam = CreateEntity( "info_particle_system" )
		zapBeam.kv.cpoint1 = cpEnd.GetTargetName()
		zapBeam.SetValueForEffectNameKey( TOOLGUN_GRAB_EFFECT )
		zapBeam.kv.start_active = 0
		zapBeam.SetOrigin( player.EyePosition() )
		DispatchSpawn( zapBeam )
		zapBeam.Fire( "Start" )
		ToolgunGrab.GrabBeamEffect = zapBeam;
		*/

		thread ToolgunGrab_Think( player );
		return true;
	}
	return false;
}

bool function ClientCommand_Toolgun_ReleaseEntity( entity player, array<string> args )
{
	ToolgunGrab.GrabbedEntity = null;
	// ToolgunGrab.GrabBeamEffect.Destroy();
	// ToolgunGrab.GrabBeamTarget.Destroy();

	return true;
}

bool function ClientCommand_Toolgun_Grab_StartRotate( entity player, array<string> args )
{
	ToolgunGrab.IsRotating = true;
	ToolgunGrab.LockViewAngle = Vector( args[0].tofloat(), args[1].tofloat(), args[2].tofloat() );
	return true;
}

bool function ClientCommand_Toolgun_Grab_StopRotate( entity player, array<string> args )
{
	ToolgunGrab.IsRotating = false;
	return true;
}

bool function ClientCommand_Toolgun_Grab_PerformRotation( entity player, array<string> args )
{
	if( ToolgunGrab.GrabbedEntity != null )
	{
#if TOOLGUN_ENABLE_MOUSE_ROTATE
		// bad but working mouse rotation
		/*
		vector rotation = Vector( args[0].tofloat() * 100, args[1].tofloat() * 100, args[2].tofloat() * 100 );
		vector angles = AnglesCompose( ToolgunGrab.GrabbedEntity.GetAngles(), Vector( 0.0, args[1].tofloat() * 10.0, 0.0 ) );
		angles = AnglesCompose( angles, Vector( args[0].tofloat() * 10.0, 0.0, 0.0 ) );
		*/

		// better, but still bad mouse rotation
		float xInput = args[0].tofloat() * 50;
		float yInput = args[1].tofloat() * 50;
		vector entAngles = ToolgunGrab.GrabbedEntity.GetAngles();
		if ( fabs( xInput ) + fabs( yInput ) >= 0.05 )
		{
			if ( fabs( yInput ) > fabs( xInput ) )
				entAngles = AnglesCompose( entAngles, Vector( xInput, 0.0, 0.0 ) )
			else
				entAngles = AnglesCompose( entAngles, Vector( 0.0, yInput, 0.0 ) )

			ToolgunGrab.GrabbedEntity.SetAngles( entAngles )
		}
#else
		float pitchInput = args[0].tofloat();
		float yawInput = args[1].tofloat();
		float rollInput = args[2].tofloat();

		if(pitchInput == -1 && yawInput == -1 && rollInput == -1)
		{
			ToolgunGrab.GrabbedEntity.SetAngles( Vector(0, 0, 0) );
		}
		else
		{
			float rotateSpeed = 15;
			vector rotationInput = Vector( pitchInput, yawInput, rollInput ) * rotateSpeed;

			vector entAngles = ToolgunGrab.GrabbedEntity.GetAngles();
			entAngles = AnglesCompose( entAngles, rotationInput );
			ToolgunGrab.GrabbedEntity.SetAngles( entAngles );
		}
#endif

	}
	return true;
}

bool function ClientCommand_Toolgun_ChangeModel( entity player, array<string> args )
{
	int Index = args[0].tointeger();
	ToolGunSettings.SelectedModel = SpawnList[ Index ];
	return true;
}

void function ToolgunGrab_Think( entity player )
{
	while( ToolgunGrab.GrabbedEntity != null )
	{
		vector origin = player.EyePosition()
		vector angles = player.EyeAngles()
		vector forward = AnglesToForward( angles )
		ToolgunGrab.GrabbedEntity.SetOrigin( origin + forward * ToolgunGrab.GrabDistance + ToolgunGrab.GrabOffset )

		if( ToolgunGrab.IsRotating )
		{
			player.SnapEyeAngles( ToolgunGrab.LockViewAngle );

			// vector entAngles = ToolgunGrab.GrabbedEntity.GetAngles();
			// entAngles.y = (entAngles.y + 45 * FrameTime()) % 360.0
			// ToolgunGrab.GrabbedEntity.SetAngles( entAngles );
		}

		// ToolgunGrab.GrabBeamEffect.SetOrigin( player.EyePosition() + AnglesToRight( angles ) * 5 + AnglesToUp( angles ) * -5 )
		// ToolgunGrab.GrabBeamTarget.SetOrigin( origin + forward * ToolgunGrab.GrabDistance + ToolgunGrab.GrabOffset )

		wait 0.016;
	}
}

#endif

#if CLIENT

struct {
	entity GrabbedEntity,
	bool IsRotating,
	float OriginalSensitivity,
	vector LastEyeAngles
} ToolgunGrab;

void function Toolgun_Client_Init()
{
	RegisterButtonPressedCallback( KEY_PAD_MINUS, KeyPress_ToolgunPrevMode );
	RegisterButtonPressedCallback( KEY_PAD_PLUS, KeyPress_ToolgunNextMode );

	RegisterButtonPressedCallback( KEY_PAD_ENTER, KeyPress_ToolgunRandomProp );

	RegisterButtonPressedCallback( MOUSE_RIGHT, MousePress_ToolgunGrab );
	RegisterButtonReleasedCallback( MOUSE_RIGHT, MouseRelease_ToolgunGrab );

#if TOOLGUN_ENABLE_MOUSE_ROTATE
	// Renable for toolgun mouse rotation
	RegisterButtonPressedCallback( KEY_E, KeyPress_ToolgunRotate );
	RegisterButtonReleasedCallback( KEY_E, KeyRelease_ToolgunRotate );
#endif

	// todo: better prop rotation
	RegisterButtonPressedCallback( KEY_PAD_8, KeyPress_ToolgunRotate_PitchUp );
	RegisterButtonPressedCallback( KEY_PAD_2, KeyPress_ToolgunRotate_PitchDown );
	RegisterButtonPressedCallback( KEY_PAD_4, KeyPress_ToolgunRotate_YawLeft );
	RegisterButtonPressedCallback( KEY_PAD_6, KeyPress_ToolgunRotate_YawRight );
	RegisterButtonPressedCallback( KEY_PAD_7, KeyPress_ToolgunRotate_RollLeft );
	RegisterButtonPressedCallback( KEY_PAD_9, KeyPress_ToolgunRotate_RollRight );
	RegisterButtonPressedCallback( KEY_PAD_5, KeyPress_ToolgunRotate_Reset );
}

bool function Toolgun_Client_PrimaryAttack( entity player )
{
	if( Toolgun_GetCurrentModeFunction() != null )
	{
		array<string> args = [];
		Toolgun_GetCurrentModeFunction()( player, args );
		return true
	}
	return false
}

void function KeyPress_ToolgunNextMode( var button )
{
	Toolgun_Client_ChangeTool( 1 );
}

void function KeyPress_ToolgunPrevMode( var button )
{
	Toolgun_Client_ChangeTool( -1 );
}

void function Toolgun_Client_ChangeTool( int Change )
{
	ToolGunSettings.CurrentModeIdx = ToolGunSettings.CurrentModeIdx + Change;
	if(ToolGunSettings.CurrentModeIdx == ToolGunTools.len())
	{
		ToolGunSettings.CurrentModeIdx = 0;
	}
	if(ToolGunSettings.CurrentModeIdx < 0)
	{
		ToolGunSettings.CurrentModeIdx = ToolGunTools.len() - 1;
	}

	EmitSoundOnEntity( GetLocalClientPlayer(), "menu_focus" );
	GetLocalClientPlayer().ClientCommand( "Toolgun_SetMode " + ToolGunSettings.CurrentModeIdx );
}

void function MousePress_ToolgunGrab( var button )
{
	AddPlayerHint( 0.5, 0.25, $"", "Toolgun Grab" );

	entity player = GetLocalClientPlayer();
	vector eyePosition = player.EyePosition();
	vector viewVector = player.GetViewVector();
	TraceResults traceResults = TraceLine( eyePosition, eyePosition + viewVector * 10000, player, TRACE_MASK_PLAYERSOLID | TRACE_MASK_TITANSOLID | TRACE_MASK_NPCWORLDSTATIC, TRACE_COLLISION_GROUP_NONE )
	if( traceResults.hitEnt )
	{
		ToolgunGrab.GrabbedEntity = traceResults.hitEnt;
		if( ToolgunGrab.GrabbedEntity != null )
		{
			var GrabDistance = Length(traceResults.endPos - eyePosition);
			vector GrabOffset = ToolgunGrab.GrabbedEntity.GetOrigin() - traceResults.endPos;
			var cmd = "Toolgun_GrabEntity " + ToolgunGrab.GrabbedEntity.GetEntIndex() + " " + GrabOffset.x + " " + GrabOffset.y + " " + GrabOffset.z + " " + GrabDistance;
			GetLocalClientPlayer().ClientCommand( cmd );
			thread ToolgunGrab_Think();
		}
	}
}

void function MouseRelease_ToolgunGrab( var button )
{
	AddPlayerHint( 0.5, 0.25, $"", "Toolgun Release" );
	ToolgunGrab.GrabbedEntity = null;
	GetLocalClientPlayer().ClientCommand( "Toolgun_ReleaseEntity" );
}

void function KeyPress_ToolgunRotate( var button )
{
	AddPlayerHint( 0.5, 0.25, $"", "Toolgun rotate on" );

	ToolgunGrab.IsRotating = true;

#if TOOLGUN_ENABLE_MOUSE_ROTATE
	ToolgunGrab.OriginalSensitivity = GetConVarFloat( "mouse_sensitivity_zoomed" );
	SetConVarFloat( "mouse_sensitivity_zoomed", 0.001 );
#endif

	entity player = GetLocalClientPlayer();
	vector angles = player.EyeAngles();
	ToolgunGrab.LastEyeAngles = angles;

	GetLocalClientPlayer().ClientCommand( "Toolgun_Grab_StartRotate " + angles.x + " " + angles.y + " " + angles.z );
}

void function KeyRelease_ToolgunRotate( var button )
{
	AddPlayerHint( 0.5, 0.25, $"", "Toolgun rotate off" );

#if TOOLGUN_ENABLE_MOUSE_ROTATE
	SetConVarFloat( "mouse_sensitivity_zoomed", ToolgunGrab.OriginalSensitivity );
#endif

	ToolgunGrab.IsRotating = false;
	GetLocalClientPlayer().ClientCommand( "Toolgun_Grab_StopRotate" );
}

void function Toolgun_PerformRotate( float x, float y, float z )
{
	// AddPlayerHint( 0.5, 0.25, $"", "Rotate " + x + " " + y + " " + z );
	GetLocalClientPlayer().ClientCommand( "Toolgun_Grab_PerformRotation " + x + " " + y + " " + z );
}

void function KeyPress_ToolgunRotate_PitchUp( var button )
{
	Toolgun_PerformRotate( 1, 0, 0 );
}

void function KeyPress_ToolgunRotate_PitchDown( var button )
{
	Toolgun_PerformRotate( -1, 0, 0 );
}

void function KeyPress_ToolgunRotate_YawLeft( var button )
{
	Toolgun_PerformRotate( 0, -1, 0 );
}

void function KeyPress_ToolgunRotate_YawRight( var button )
{
	Toolgun_PerformRotate( 0, 1, 0 );
}

void function KeyPress_ToolgunRotate_RollLeft( var button )
{
	Toolgun_PerformRotate( 0, 0, -1 );
}

void function KeyPress_ToolgunRotate_RollRight( var button )
{
	Toolgun_PerformRotate( 0, 0, 1 );
}

void function KeyPress_ToolgunRotate_Reset( var button )
{
	Toolgun_PerformRotate( -1, -1, -1 );
}

void function KeyPress_ToolgunRandomProp( var button )
{
	int RandomIndex = RandomIntRange( 0, SpawnList.len() - 1 );
	ToolGunSettings.SelectedModel = SpawnList[ RandomIndex ];

	PrecacheModel( ToolGunSettings.SelectedModel );
	AddPlayerHint( 0.5, 0.15, $"", "Spawning: " + ToolGunSettings.SelectedModel );
	GetLocalClientPlayer().ClientCommand( "Toolgun_ChangeModel " + RandomIndex );
}

void function ToolgunGrab_Think()
{
	while( ToolgunGrab.GrabbedEntity != null )
	{
		entity player = GetLocalClientPlayer();
		vector origin = player.EyePosition();
		vector angles = player.EyeAngles();
		vector forward = AnglesToForward( angles );

#if TOOLGUN_ENABLE_MOUSE_ROTATE
		if( ToolgunGrab.IsRotating )
		{
			vector diff = ToolgunGrab.LastEyeAngles - angles;
			player.ClientCommand( "Toolgun_Grab_PerformRotation " + diff.x + " " + diff.y + " " + diff.z );
		}
#endif

		WaitFrame();
	}
}

#endif

#if CLIENT

array<var> ruis = [];
array<var> grabModeRuis = [];
var ruiToolgunMode = null;
var ruiToolgunHelp = null;

void function Toolgun_UI_Init()
{
	var rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", clGlobal.topoCockpitHudPermanent, RUI_DRAW_COCKPIT, 0 )
	RuiSetInt( rui, "maxLines", 1 )
	RuiSetInt( rui, "lineNum", 1 )
	RuiSetFloat2( rui, "msgPos", <0.05, 0.05, 0.0> )
	RuiSetString( rui, "msgText", "Toolgun" )
	RuiSetFloat( rui, "msgFontSize", 48.0 )
	RuiSetFloat( rui, "msgAlpha", 0.9 )
	RuiSetFloat( rui, "thicken", 0.0 )
	RuiSetFloat3( rui, "msgColor", <1.0, 1.0, 1.0> )
	ruis.append(rui)

	rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", clGlobal.topoCockpitHudPermanent, RUI_DRAW_COCKPIT, 0 )
	RuiSetInt( rui, "maxLines", 1 )
	RuiSetInt( rui, "lineNum", 1 )
	RuiSetFloat2( rui, "msgPos", <0.05, 0.1, 0.0> )
	RuiSetString( rui, "msgText", "Mode: None" )
	RuiSetFloat( rui, "msgFontSize", 32.0 )
	RuiSetFloat( rui, "msgAlpha", 0.9 )
	RuiSetFloat( rui, "thicken", 0.0 )
	RuiSetFloat3( rui, "msgColor", <1.0, 1.0, 1.0> )
	ruis.append(rui)
	ruiToolgunMode = rui

	rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", clGlobal.topoCockpitHudPermanent, RUI_DRAW_COCKPIT, 0 )
	RuiSetInt( rui, "maxLines", 2 )
	RuiSetInt( rui, "lineNum", 2 )
	RuiSetFloat2( rui, "msgPos", <0.05, 0.1, 0.0> )
	RuiSetString( rui, "msgText", "Help text" )
	RuiSetFloat( rui, "msgFontSize", 32.0 )
	RuiSetFloat( rui, "msgAlpha", 0.9 )
	RuiSetFloat( rui, "thicken", 0.0 )
	RuiSetFloat3( rui, "msgColor", <1.0, 1.0, 1.0> )
	ruis.append(rui)
	ruiToolgunHelp = rui

	float X = 0.80;
	float Y = 0.65;
	float W = 0.05;
	float H = 0.05;

	float _x = X;
	float _y = Y;

	_x = X;
	AddKeypadRuiSmall( "Num\nLock", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );
	_x += W;
	AddKeypadRui( "/", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );
	_x += W;
	AddKeypadRui( "*", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );
	_x += W;
	AddKeypadRui( "-", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );

	_x = X;
	_y += H;
	AddKeypadRui( "7\nR-", < _x, _y, 0.0 >, <0.0, 0.0, 1.0> );
	_x += W;
	AddKeypadRui( "8\nP+", < _x, _y, 0.0 >, <1.0, 0.0, 0.0> );
	_x += W;
	AddKeypadRui( "9\nR+", < _x, _y, 0.0 >, <0.0, 0.0, 1.0> );
	_x += W;
	_y += H * 0.5;
	AddKeypadRui( "+", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );

	_x = X;
	_y += H;
	AddKeypadRui( "4\nY-", < _x, _y, 0.0 >, <0.0, 1.0, 0.0> );
	_x += W;
	AddKeypadRui( "5\nRst", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );
	_x += W;
	AddKeypadRui( "6\nY+", < _x, _y, 0.0 >, <0.0, 1.0, 0.0> );
	_x += W;
	_y += H * 0.5;
	AddKeypadRuiSmall( "Enter", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );

	_x = X;
	_y += H;
	AddKeypadRui( "1", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );
	_x += W;
	AddKeypadRui( "2\nP-", < _x, _y, 0.0 >, <1.0, 0.0, 0.0> );
	_x += W;
	AddKeypadRui( "3", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );

	_x = X;
	_y += H;
	_x += W * 0.5;
	AddKeypadRui( "0", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );
	_x += W * 0.5;
	_x += W;
	AddKeypadRui( ".", < _x, _y, 0.0 >, <1.0, 1.0, 1.0> );

	thread Toolgun_UI_UpdateToolgunHelp()
}

void function AddKeypadRui( string text, vector position, vector color )
{
	var rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", clGlobal.topoCockpitHudPermanent, RUI_DRAW_COCKPIT, 0 )
	RuiSetInt( rui, "maxLines", 1 )
	RuiSetInt( rui, "lineNum", 1 )
	RuiSetFloat2( rui, "msgPos", position )
	RuiSetString( rui, "msgText", text )
	RuiSetFloat( rui, "msgFontSize", 32.0 )
	RuiSetFloat( rui, "msgAlpha", 0.9 )
	RuiSetFloat( rui, "thicken", 0.0 )
	RuiSetFloat3( rui, "msgColor", color )
	grabModeRuis.append( rui );
}

void function AddKeypadRuiSmall( string text, vector position, vector color )
{
	var rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", clGlobal.topoCockpitHudPermanent, RUI_DRAW_COCKPIT, 0 )
	RuiSetInt( rui, "maxLines", 1 )
	RuiSetInt( rui, "lineNum", 1 )
	RuiSetFloat2( rui, "msgPos", position )
	RuiSetString( rui, "msgText", text )
	RuiSetFloat( rui, "msgFontSize", 24.0 )
	RuiSetFloat( rui, "msgAlpha", 0.9 )
	RuiSetFloat( rui, "thicken", 0.0 )
	RuiSetFloat3( rui, "msgColor", color )
	grabModeRuis.append( rui );
}

bool function Toolgun_IsHoldingToolgun()
{
	entity player = GetLocalClientPlayer()
	if( player )
	{
		entity plyWeapon = player.GetActiveWeapon()
		if( plyWeapon != null )
		{
			return plyWeapon.GetWeaponClassName() == "mp_weapon_shotgun_pistol";
		}
	}
	return false;
}

void function Toolgun_UI_UpdateToolgunHelp()
{
	while ( true )
	{
		bool displayUi = Toolgun_IsHoldingToolgun();
		foreach( rui in ruis )
		{
			if( displayUi )
			{
				RuiSetFloat( rui, "msgAlpha", 0.9 )
			}
			else
			{
				RuiSetFloat( rui, "msgAlpha", 0.0 )
			}
		}

		foreach( rui in grabModeRuis )
		{
			if( displayUi && ToolgunGrab.GrabbedEntity != null )
			{
				RuiSetFloat( rui, "msgAlpha", 0.9 )
			}
			else
			{
				RuiSetFloat( rui, "msgAlpha", 0.0 )
			}
		}

		RuiSetString( ruiToolgunMode, "msgText", "Mode: " + Toolgun_GetCurrentMode().name )
		RuiSetString( ruiToolgunHelp, "msgText", Toolgun_GetCurrentMode().help )

		WaitFrame()
	}
}

#endif

// DisablePrecacheErrors()
// wait 0.5

bool function Toolgun_Func_SpawnProp( entity player, array<string> args )
{
#if SERVER
	/*
	entity prop_dynamic = CreateEntity( "prop_dynamic" )
	prop_dynamic.SetValueForModelKey( ToolGunSettings.SelectedModel )
	prop_dynamic.kv.fadedist = -1
	prop_dynamic.kv.renderamt = 255
	prop_dynamic.kv.rendercolor = "255 255 255"
	prop_dynamic.kv.solid = 6 // 0 = no collision, 2 = bounding box, 6 = use vPhysics, 8 = hitboxes only
	SetTeam( prop_dynamic, TEAM_BOTH )	// need to have a team other then 0 or it won't take impact damage

	entity player = GetPlayerByIndex( 0 )
	vector origin = player.EyePosition()
	vector angles = player.EyeAngles()
	vector forward = AnglesToForward( angles )

	prop_dynamic.SetOrigin( origin + forward * 200 )
	// prop_dynamic.SetAngles( Vector(RandomFloat(360), RandomFloat(360), RandomFloat(360)) )
	prop_dynamic.SetAngles( Vector(0, player.EyeAngles().y, 0) );
	DispatchSpawn( prop_dynamic )
	*/

	thread Toolgun_Func_SpawnProp_Precache();
	Toolgun_Utils_FireToolTracer( player );

	return true
#else
	return false
#endif
}

#if SERVER
void function Toolgun_Func_SpawnProp_Precache()
{

	// DisablePrecacheErrors()
	// wait 0.5
	PrecacheModel( ToolGunSettings.SelectedModel )
	// wait 0.5

	while( !ModelIsPrecached( ToolGunSettings.SelectedModel ) )
	{
		wait 0.5
	}

	entity prop_dynamic = CreateEntity( "prop_dynamic" )
	// prop_dynamic.SetValueForModelKey( SPAWN_MODEL )
	prop_dynamic.SetValueForModelKey( ToolGunSettings.SelectedModel )
	prop_dynamic.kv.fadedist = -1
	prop_dynamic.kv.renderamt = 255
	prop_dynamic.kv.rendercolor = "255 255 255"
	prop_dynamic.kv.solid = 6 // 0 = no collision, 2 = bounding box, 6 = use vPhysics, 8 = hitboxes only
	SetTeam( prop_dynamic, TEAM_BOTH )	// need to have a team other then 0 or it won't take impact damage

	entity player = GetPlayerByIndex( 0 )
	vector origin = player.EyePosition()
	vector angles = player.EyeAngles()
	vector forward = AnglesToForward( angles )

	prop_dynamic.SetOrigin( origin + forward * 200 )
	// prop_dynamic.SetAngles( Vector(RandomFloat(360), RandomFloat(360), RandomFloat(360)) )
	prop_dynamic.SetAngles( Vector(0, player.EyeAngles().y, 0) );
	DispatchSpawn( prop_dynamic )

}
#endif

bool function Toolgun_Func_RemoveProp( entity player, array<string> args )
{
#if SERVER
	vector eyePosition = player.EyePosition()
	vector viewVector = player.GetViewVector()
	TraceResults traceResults = TraceLine( eyePosition, eyePosition + viewVector * 10000, player, TRACE_MASK_PLAYERSOLID, TRACE_COLLISION_GROUP_PLAYER )
	if( traceResults.hitEnt && traceResults.hitEnt.GetClassName() != "prop_static" )
	{
		Toolgun_Utils_FireToolTracer( player );
		traceResults.hitEnt.Destroy();
		return true
	}
	return false
#else
	return false
#endif
}

bool function Toolgun_Func_PropInfo( entity player, array<string> args )
{
#if SERVER
	Toolgun_Utils_FireToolTracer( player );
	return false;
#else
	vector eyePosition = player.EyePosition()
	vector viewVector = player.GetViewVector()
	TraceResults traceResults = TraceLine( eyePosition, eyePosition + viewVector * 10000, player, TRACE_MASK_PLAYERSOLID | TRACE_MASK_TITANSOLID | TRACE_MASK_NPCWORLDSTATIC, TRACE_COLLISION_GROUP_NONE )
	if( traceResults.hitEnt )
	{
		AddPlayerHint( 2.0, 0.25, $"", "Output " + traceResults.hitEnt.GetModelName() + " to console" )
		printc( "Model: ", traceResults.hitEnt.GetModelName() )
		return true
	}
	return false
#endif
}

#if SERVER

void function CustomGauntlet_Server_Init()
{
	AddClientCommandCallback( "CustomGauntlet_DevToggleActive", ClientCommand_CustomGauntlet_DevToggleActive )
	AddClientCommandCallback( "CustomGauntlet_PlaceEntity", ClientCommand_CustomGauntlet_PlaceGauntletEntity )

	thread CustomGauntlet_Server_Think();
}

void function CustomGauntlet_Server_Think()
{
	while( true )
	{
		if( CustomGauntlet.IsActive )
		{
			entity player = GetPlayerByIndex( 0 );

			float DistanceToStart = Length( player.GetOrigin() - CustomGauntlet.StartPoint.Location );
			if( DistanceToStart < 100 )
			{
				CustomGauntlet_Start_Server();
			}

			float DistanceToFinish = Length( player.GetOrigin() - CustomGauntlet.FinishPoint.Location );
			if( DistanceToFinish < 100 )
			{
				CustomGauntlet_Finish_Server();
			}
		}

		WaitFrame()
	}
}

void function CustomGauntlet_Reset_Server()
{
	CustomGauntlet.Started = false;
	CustomGauntlet.Finished = false;
}

void function CustomGauntlet_Start_Server()
{
	if( CustomGauntlet.Started || CustomGauntlet.Finished )
	{
		return;
	}

	CustomGauntlet.Started = true;
	CustomGauntlet.StartTime = Time();

	entity player = GetPlayerByIndex( 0 );
	RestockPlayerAmmo( player );
	EmitSoundOnEntityOnlyToPlayer( player, player, "training_scr_gaunlet_start" );

	CustomGauntlet_SpawnTargetNPCs();

	Remote_CallFunction_Replay( player, "ServerCallback_Gauntlet_StartRun" )
}

void function CustomGauntlet_Finish_Server()
{
	if( CustomGauntlet.Finished || !CustomGauntlet.Started )
	{
		return;
	}

	CustomGauntlet.Finished = true;

	int TotalEnemies = CustomGauntlet_GetTotalNumberOfEnemies();
	int EnemiesKilled = TotalEnemies - CustomGauntlet.NumberOfTargetsAlive;
	float MissedEnemiesPenalty = CustomGauntlet.NumberOfTargetsAlive * GAUNTLET_ENEMY_MISSED_TIME_PENALTY;
	float RunTime = Time() - CustomGauntlet.StartTime + MissedEnemiesPenalty;

	if( CustomGauntlet.BestRunTime == -1.0 || RunTime < CustomGauntlet.BestRunTime )
	{
		CustomGauntlet.BestRunTime = RunTime;
	}

	entity player = GetPlayerByIndex( 0 );
	RestockPlayerAmmo( player );
	EmitSoundOnEntityOnlyToPlayer( player, player, "training_scr_gaunlet_end" );

	CustomGauntlet_ClearTargetNPCs();
	thread ClearDroppedWeapons( GAUNTLET_TARGET_DISSOLVE_TIME * 1.25 );

	Remote_CallFunction_Replay( player, "ServerCallback_Gauntlet_FinishRun", RunTime, CustomGauntlet.BestRunTime, MissedEnemiesPenalty, TotalEnemies, EnemiesKilled );
	CustomGauntlet_UpdateNumberOfEnemiesKilled();
}

int function CustomGauntlet_GetTotalNumberOfEnemies()
{
	return CustomGauntlet.TargetPoints.len();
}

void function CustomGauntlet_SpawnTargetNPCs()
{
	CustomGauntlet_ClearTargetNPCs();

	CustomGauntlet.NumberOfTargetsAlive = 0;
	for( int i = 0; i < CustomGauntlet.TargetPoints.len(); ++i )
	{
		entity SpawnedGrunt = CreateSoldier( TEAM_IMC, CustomGauntlet.TargetPoints[i].Location, CustomGauntlet.TargetPoints[i].Rotation + <0, 180, 0> );
		DispatchSpawn( SpawnedGrunt );

		Highlight_SetEnemyHighlightWithParam1( SpawnedGrunt, "gauntlet_target_highlight", SpawnedGrunt.EyePosition() );
		SpawnedGrunt.SetHealth( 1 );
		SpawnedGrunt.SetCanBeMeleeExecuted( false );
		SpawnedGrunt.SetNoTarget( true );
		SpawnedGrunt.SetEfficientMode( true );
		SpawnedGrunt.SetHologram();
		SpawnedGrunt.SetDeathActivity( "ACT_DIESIMPLE" );
		SpawnedGrunt.Freeze();

		AddEntityCallback_OnDamaged( SpawnedGrunt, CustomGauntlet_NPC_Damaged );

		CustomGauntlet.SpawnedTargets.append( SpawnedGrunt );
		CustomGauntlet.NumberOfTargetsAlive++;
	}

	CustomGauntlet_UpdateNumberOfEnemiesKilled();
}

void function CustomGauntlet_ClearTargetNPCs()
{
	for( int i = 0; i < CustomGauntlet.SpawnedTargets.len(); ++i )
	{
		entity npc = CustomGauntlet.SpawnedTargets[i];
		if( IsValid( npc ) && IsAlive( npc ) )
		{
			if ( npc.IsFrozen() )
			{
				npc.Unfreeze()
			}
			npc.Die();
		}
	}
}

void function CustomGauntlet_NPC_Damaged( entity npc, var damageInfo )
{
	float dmg = DamageInfo_GetDamage( damageInfo )
	float finalHealth = npc.GetHealth() - dmg
	if ( finalHealth <= 0 && npc.IsFrozen() )
	{
		npc.Unfreeze()
		EmitSoundAtPosition( TEAM_UNASSIGNED, npc.GetOrigin(), "holopilot_impacts_training" )
		npc.Dissolve( ENTITY_DISSOLVE_PHASESHIFT, Vector( 0, 0, 0 ), GAUNTLET_TARGET_DISSOLVE_TIME )
		CustomGauntlet.NumberOfTargetsAlive--;
		CustomGauntlet_UpdateNumberOfEnemiesKilled();
	}
}

void function CustomGauntlet_UpdateNumberOfEnemiesKilled()
{
	entity player = GetPlayerByIndex( 0 );
	int TotalEnemies = CustomGauntlet_GetTotalNumberOfEnemies();
	int EnemiesKilled = TotalEnemies - CustomGauntlet.NumberOfTargetsAlive;
	Remote_CallFunction_Replay( player, "ServerCallback_Gauntlet_UpdateEnemiesKilled", TotalEnemies, EnemiesKilled );
}

// -----------------------------------------------------------------------------

bool function ClientCommand_CustomGauntlet_DevToggleActive( entity player, array<string> args )
{
	bool active = (args[0] == "1");
	CustomGauntlet.IsActive = active;
	CustomGauntlet_Reset_Server();
	return true;
}

bool function ClientCommand_CustomGauntlet_PlaceGauntletEntity( entity player, array<string> args )
{
	string EntId = args[0];
	vector Pos = Vector( args[1].tofloat(), args[2].tofloat(), args[3].tofloat() );
	vector Ang = Vector( args[4].tofloat(), args[5].tofloat(), args[6].tofloat() );

	switch (EntId)
	{
		case "start_point":
			CustomGauntlet.StartPoint.Location = Pos;
			CustomGauntlet.StartPoint.Rotation = Ang;
			break;
		case "finish_point":
			CustomGauntlet.FinishPoint.Location = Pos;
			CustomGauntlet.FinishPoint.Rotation = Ang;
			break;
		case "target":
			WorldPoint TargetPoint;
			TargetPoint.Location = Pos;
			TargetPoint.Rotation = Ang;
			CustomGauntlet.TargetPoints.append( TargetPoint );
			break;
		case "leaderboard":
			CustomGauntlet.LeaderboardPoint.Location = Pos;
			CustomGauntlet.LeaderboardPoint.Rotation = Ang;
			break;
		case "results":
			CustomGauntlet.ResultsPoint.Location = Pos;
			CustomGauntlet.ResultsPoint.Rotation = Ang;
			break;
		default:
			return false;
	}
	return true;
}

#endif

const float GAUNTLET_TARGET_DISSOLVE_TIME = 0.25 * 1000
const int GAUNTLET_LEADERBOARD_MAX_ENTRIES = 10
const float GAUNTLET_ENEMY_MISSED_TIME_PENALTY = 2.0

struct WorldPoint
{
	vector Location,
	vector Rotation
}

struct
{
	bool IsActive,
	bool Started,
	bool Finished,

	float StartTime,
	float LastRunTime,
	float BestRunTime = -1.0,

	WorldPoint StartPoint,
	WorldPoint FinishPoint,
	array<WorldPoint> TargetPoints,
	WorldPoint LeaderboardPoint,
	WorldPoint ResultsPoint,

	var StartDisplayTopology,
	var StartDisplayRui,
	var FinishDisplayTopology,
	var FinishDisplayRui,
	array<var> TargetRuis,
	var LeaderboardTopology,
	var LeaderboardRui,
	var ResultsTopology,
	var ResultsRui,
	var SplashRui,

	var IsActiveRui

	array<entity> SpawnedTargets,
	int NumberOfTargetsAlive,

#if CLIENT
	int TipIdx,
	array<string> Tips,
	var HUDRui,
#endif

	var STRUCT_MAX

} CustomGauntlet;

void function CustomGauntlet_Shared_Init()
{
	CustomGauntlet_Shared_RegisterTools();

	#if SERVER
	CustomGauntlet_Server_Init();
	#endif

	#if CLIENT
	CustomGauntlet_Client_Init();
	CustomGauntlet_UI_Init();
	#endif
}

void function CustomGauntlet_Shared_RegisterTools()
{
	table ToolGauntletStart = {}
	ToolGauntletStart.id <- "gauntlet_place_start"
	ToolGauntletStart.name <- "Gauntlet Start"
	ToolGauntletStart.help <- "Left click to place the start for a gauntlet"
	ToolGunTools.append( ToolGauntletStart )
	ToolGunToolFunctions.append( Toolgun_Func_Gauntlet_PlaceStart )

	table ToolGauntletFinish = {}
	ToolGauntletFinish.id <- "gauntlet_place_finish"
	ToolGauntletFinish.name <- "Gauntlet Finish"
	ToolGauntletFinish.help <- "Left click to place the finish for a gauntlet"
	ToolGunTools.append( ToolGauntletFinish )
	ToolGunToolFunctions.append( Toolgun_Func_Gauntlet_PlaceFinish )

	table ToolGauntletTarget = {}
	ToolGauntletTarget.id <- "gauntlet_place_target"
	ToolGauntletTarget.name <- "Gauntlet Target"
	ToolGauntletTarget.help <- "Left click to place a target for a gauntlet"
	ToolGunTools.append( ToolGauntletTarget )
	ToolGunToolFunctions.append( Toolgun_Func_Gauntlet_PlaceTarget )

	table ToolGauntletLeaderboard = {}
	ToolGauntletLeaderboard.id <- "gauntlet_place_leaderboard"
	ToolGauntletLeaderboard.name <- "Gauntlet Leaderboard"
	ToolGauntletLeaderboard.help <- "Left click to place a leaderboard for a gauntlet"
	ToolGunTools.append( ToolGauntletLeaderboard )
	ToolGunToolFunctions.append( Toolgun_Func_Gauntlet_PlaceLeaderboard )

	table ToolGauntletResults = {}
	ToolGauntletResults.id <- "gauntlet_place_results"
	ToolGauntletResults.name <- "Gauntlet Results Board"
	ToolGauntletResults.help <- "Left click to place a results board for a gauntlet"
	ToolGunTools.append( ToolGauntletResults )
	ToolGunToolFunctions.append( Toolgun_Func_Gauntlet_PlaceResults )
	
}

#if CLIENT

void function CustomGauntlet_Client_Init()
{
	RegisterButtonPressedCallback( KEY_BACKSLASH, KeyPress_TestGauntlet );

	CustomGauntlet.Tips.append( "#GAUNTLET_TIP_0" );
	CustomGauntlet.Tips.append( "#GAUNTLET_TIP_1" );
	CustomGauntlet.Tips.append( "#GAUNTLET_TIP_2" );
	CustomGauntlet.Tips.append( "#GAUNTLET_TIP_3" );
	CustomGauntlet.Tips.append( "#GAUNTLET_TIP_4" );
	CustomGauntlet.Tips.append( "#GAUNTLET_TIP_5" );
	CustomGauntlet.Tips.append( "#GAUNTLET_TIP_6" );
	CustomGauntlet.Tips.append( "#GAUNTLET_TIP_7" );
	CustomGauntlet.Tips.append( "#GAUNTLET_TIP_8" );
	CustomGauntlet.Tips.append( "#GAUNTLET_TIP_9" );
	CustomGauntlet.Tips.randomize();

	thread CustomGauntlet_Client_Think();
}

void function CustomGauntlet_Client_Think()
{
	while( true )
	{
		WaitFrame()
	}
}

// -----------------------------------------------------------------------------

void function CustomGauntlet_PlaceStartLine( vector Pos, vector Ang )
{
	CustomGauntlet.StartPoint.Location = Pos;
	CustomGauntlet.StartPoint.Rotation = Pos;

	CustomGauntlet_DestroyStartLine();

	CustomGauntlet.StartDisplayTopology = CustomGauntlet_CreateCentredTopology( Pos, Ang, 60, 30 );
	CustomGauntlet.StartDisplayRui = RuiCreate( $"ui/gauntlet_starting_line.rpak", CustomGauntlet.StartDisplayTopology, RUI_DRAW_WORLD, 0 )
	RuiSetString( CustomGauntlet.StartDisplayRui, "displayText", "#GAUNTLET_START_TEXT" );

	CustomGauntlet_SendEntityToServer( "start_point", Pos, Ang );
}

void function CustomGauntlet_PlaceFinishLine( vector Pos, vector Ang )
{
	CustomGauntlet.FinishPoint.Location = Pos;
	CustomGauntlet.FinishPoint.Rotation = Pos;

	CustomGauntlet_DestroyFinishLine();

	CustomGauntlet.FinishDisplayTopology = CustomGauntlet_CreateCentredTopology( Pos, Ang, 60, 30 );
	CustomGauntlet.FinishDisplayRui = RuiCreate( $"ui/gauntlet_starting_line.rpak", CustomGauntlet.FinishDisplayTopology, RUI_DRAW_WORLD, 0 )
	RuiSetString( CustomGauntlet.FinishDisplayRui, "displayText", "#GAUNTLET_FINISH_TEXT" );

	CustomGauntlet_SendEntityToServer( "finish_point", Pos, Ang );
}

void function CustomGauntlet_PlaceTarget( vector Pos, vector Ang )
{
	WorldPoint TargetPoint;
	TargetPoint.Location = Pos;
	TargetPoint.Rotation = Ang;
	CustomGauntlet.TargetPoints.append( TargetPoint );

	var TargetTopology = CustomGauntlet_CreateCentredTopology( Pos, Ang, 60, 30 );
	var TargetRui = RuiCreate( $"ui/gauntlet_starting_line.rpak", TargetTopology, RUI_DRAW_WORLD, 0 )
	RuiSetString( TargetRui, "displayText", "Target" );
	CustomGauntlet.TargetRuis.append( TargetRui );

	CustomGauntlet_SendEntityToServer( "target", Pos, Ang );
}

var function CustomGauntlet_CreateCentredTopology( vector Pos, vector Ang, float Width = 60, float Height = 30 )
{
	// adjust so the RUI is drawn with the org as its center point
	Pos += ( (AnglesToRight( Ang )*-1) * (Width*0.5) );
	Pos += ( AnglesToUp( Ang ) * (Height*0.5) );

	// right and down vectors that get added to base org to create the display size
	vector right = ( AnglesToRight( Ang ) * Width );
	vector down = ( (AnglesToUp( Ang )*-1) * Height );
	return RuiTopology_CreatePlane( Pos, right, down, true );
}

void function CustomGauntlet_DestroyStartLine()
{
	if( CustomGauntlet.StartDisplayRui != null )
	{
		RuiDestroyIfAlive( CustomGauntlet.StartDisplayRui );
		CustomGauntlet.StartDisplayRui = null;
	}
}

void function CustomGauntlet_DestroyFinishLine()
{
	if( CustomGauntlet.FinishDisplayRui != null )
	{
		RuiDestroyIfAlive( CustomGauntlet.FinishDisplayRui );
		CustomGauntlet.FinishDisplayRui = null;
	}
}

void function KeyPress_TestGauntlet( var button )
{
	CustomGauntlet.IsActive = !CustomGauntlet.IsActive;
	GetLocalClientPlayer().ClientCommand( "CustomGauntlet_DevToggleActive " + (CustomGauntlet.IsActive ? 1 : 0) );
}

// -----------------------------------------------------------------------------

void function CustomGauntlet_PlaceLeaderboard( vector Pos, vector Ang )
{
	if( CustomGauntlet.LeaderboardRui != null )
	{
		RuiDestroyIfAlive( CustomGauntlet.LeaderboardRui );
	}

	CustomGauntlet.LeaderboardPoint.Location = Pos;
	CustomGauntlet.LeaderboardPoint.Rotation = Ang;

	float Size = 120.0;
	CustomGauntlet.LeaderboardTopology = CustomGauntlet_CreateCentredTopology( Pos, Ang, Size, Size );
	CustomGauntlet.LeaderboardRui = RuiCreate( $"ui/gauntlet_leaderboard.rpak", CustomGauntlet.LeaderboardTopology, RUI_DRAW_WORLD, 0 )

	for(int i = 0; i < GAUNTLET_LEADERBOARD_MAX_ENTRIES; ++i)
	{
		CustomGauntlet_SetLeaderboardEntry( i, "Person " + i, i * 10.0, i == 3 );
	}

	CustomGauntlet_SendEntityToServer( "leaderboard", Pos, Ang );
}

void function CustomGauntlet_SetLeaderboardEntry( int leaderboardIdx, string name, float time, bool highlight )
{
	string nameArg = "entry" + leaderboardIdx + "Name";
	string timeArg = "entry" + leaderboardIdx + "Time";

	RuiSetString( CustomGauntlet.LeaderboardRui, nameArg, name );
	RuiSetFloat( CustomGauntlet.LeaderboardRui, timeArg, time );

	if ( highlight )
	{
		RuiSetInt( CustomGauntlet.LeaderboardRui, "highlightNameIdx", leaderboardIdx );
	}
}

// -----------------------------------------------------------------------------

void function CustomGauntlet_PlaceResults( vector Pos, vector Ang )
{
	if( CustomGauntlet.ResultsRui != null )
	{
		RuiDestroyIfAlive( CustomGauntlet.ResultsRui );
		CustomGauntlet.ResultsRui = null;
	}

	CustomGauntlet.ResultsPoint.Location = Pos;
	CustomGauntlet.ResultsPoint.Rotation = Ang;

	float Size = 120.0;
	CustomGauntlet.ResultsTopology = CustomGauntlet_CreateCentredTopology( Pos, Ang, Size, Size * 0.6 );
	CustomGauntlet.ResultsRui = RuiCreate( $"ui/gauntlet_results_display.rpak", CustomGauntlet.ResultsTopology, RUI_DRAW_WORLD, 0 );

	CustomGauntlet_SendEntityToServer( "results", Pos, Ang );
}

// -----------------------------------------------------------------------------

void function ServerCallback_Gauntlet_StartRun()
{
	if( CustomGauntlet.SplashRui != null && IsValid( CustomGauntlet.SplashRui ) )
	{
		RuiDestroyIfAlive( CustomGauntlet.SplashRui );
		CustomGauntlet.SplashRui = null;
	}
	var splashRUI = RuiCreate( $"ui/gauntlet_splash.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 );
	RuiSetFloat( splashRUI, "duration", 1.8 );
	RuiSetString( splashRUI, "message", "#GAUNTLET_START_TEXT");
	CustomGauntlet.SplashRui = splashRUI;

	CustomGauntlet.StartTime = Time();
	CustomGauntlet_CreatePlayerHUD();

	if( CustomGauntlet.ResultsRui != null )
	{
		RuiSetBool( CustomGauntlet.ResultsRui, "runFinished", false );
		RuiSetGameTime( CustomGauntlet.ResultsRui, "startTime", Time() );
	}

}

void function ServerCallback_Gauntlet_FinishRun( float RunTime, float BestRunTime, float MissedEnemiesPenalty, int TotalEnemies, int EnemiesKilled )
{
	if( CustomGauntlet.SplashRui != null && IsValid( CustomGauntlet.SplashRui ) )
	{
		RuiDestroyIfAlive( CustomGauntlet.SplashRui );
		CustomGauntlet.SplashRui = null;
	}
	var splashRUI = RuiCreate( $"ui/gauntlet_splash.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 );
	RuiSetFloat( splashRUI, "duration", 1.8 );
	RuiSetString( splashRUI, "message", "#GAUNTLET_FINISH_TEXT");
	CustomGauntlet.SplashRui = splashRUI;

	CustomGauntlet.LastRunTime = RunTime;
	CustomGauntlet.BestRunTime = BestRunTime;

	if( CustomGauntlet.ResultsRui != null )
	{
		RuiSetBool( CustomGauntlet.ResultsRui, "runFinished", true );
		RuiSetFloat( CustomGauntlet.ResultsRui, "finalTime", RunTime );
		RuiSetFloat( CustomGauntlet.ResultsRui, "bestTime", BestRunTime );
		RuiSetFloat( CustomGauntlet.ResultsRui, "enemiesMissedTimePenalty", MissedEnemiesPenalty );
		RuiSetInt( CustomGauntlet.ResultsRui, "numEnemies", TotalEnemies );
		RuiSetInt( CustomGauntlet.ResultsRui, "enemiesKilled", EnemiesKilled );

		CustomGauntlet.TipIdx++;
		if ( CustomGauntlet.TipIdx >= CustomGauntlet.Tips.len() )
		{
			CustomGauntlet.TipIdx = 0;
		}
		RuiSetString( CustomGauntlet.ResultsRui, "tipString", CustomGauntlet.Tips[CustomGauntlet.TipIdx] );
		RuiSetGameTime( CustomGauntlet.ResultsRui, "tipResetTime", Time() );
	}

	thread CustomGauntlet_FinishRun_PlayerHUD_Think( RunTime, BestRunTime, MissedEnemiesPenalty );
}

void function ServerCallback_Gauntlet_UpdateEnemiesKilled( int TotalEnemies, int EnemiesKilled )
{
	if( CustomGauntlet.ResultsRui != null )
	{
		RuiSetInt( CustomGauntlet.ResultsRui, "numEnemies", TotalEnemies );
		RuiSetInt( CustomGauntlet.ResultsRui, "enemiesKilled", EnemiesKilled );
	}
}

// -----------------------------------------------------------------------------

void function CustomGauntlet_SendEntityToServer( string Type, vector Pos, vector Ang )
{
	GetLocalClientPlayer().ClientCommand( "CustomGauntlet_PlaceEntity " + Type + " " + Pos.x + " " + Pos.y + " " + Pos.z + " " + Ang.x + " " + Ang.y + " " + Ang.z );
}

#endif

#if CLIENT

void function CustomGauntlet_UI_Init()
{
	var rui = RuiCreate( $"ui/cockpit_console_text_top_right.rpak", clGlobal.topoCockpitHudPermanent, RUI_DRAW_COCKPIT, 0 );
	RuiSetInt( rui, "maxLines", 1 );
	RuiSetInt( rui, "lineNum", 1 );
	RuiSetFloat2( rui, "msgPos", <0.95, 0.05, 0.0> );
	RuiSetString( rui, "msgText", "Gauntlet Active" );
	RuiSetFloat( rui, "msgFontSize", 48.0 );
	RuiSetFloat( rui, "msgAlpha", 0.9 );
	RuiSetFloat( rui, "thicken", 0.0 );
	RuiSetFloat3( rui, "msgColor", <1.0, 1.0, 1.0> );
	CustomGauntlet.IsActiveRui = rui;

	thread CustomGauntlet_UI_Think();
}

void function CustomGauntlet_UI_Think()
{
	while( true )
	{
		if( CustomGauntlet.IsActiveRui != null )
		{
			if( CustomGauntlet.IsActive )
				RuiSetFloat( CustomGauntlet.IsActiveRui, "msgAlpha", 0.9 );
			else
				RuiSetFloat( CustomGauntlet.IsActiveRui, "msgAlpha", 0.0 );
		}

		WaitFrame()
	}
}

// -----------------------------------------------------------------------------

void function CustomGauntlet_CreatePlayerHUD()
{
	CustomGauntlet_DestroyPlayerHUD();

	CustomGauntlet.HUDRui = RuiCreate( $"ui/gauntlet_hud.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 );
	RuiSetGameTime( CustomGauntlet.HUDRui, "startTime", Time() );

	if ( CustomGauntlet.BestRunTime > 0.0 )
	{
		RuiSetFloat( CustomGauntlet.HUDRui, "bestTime", CustomGauntlet.BestRunTime );
	}
}

void function CustomGauntlet_DestroyPlayerHUD()
{
	if ( CustomGauntlet.HUDRui != null )
	{
		RuiDestroyIfAlive( CustomGauntlet.HUDRui );
	}
	CustomGauntlet.HUDRui = null;
}

void function CustomGauntlet_FinishRun_PlayerHUD_Think( RunTime, BestRunTime, MissedEnemiesPenalty )
{
	if ( CustomGauntlet.HUDRui != null )
	{
		RuiSetBool( CustomGauntlet.HUDRui, "runFinished", true );
		RuiSetFloat( CustomGauntlet.HUDRui, "finalTime", RunTime );
		RuiSetFloat( CustomGauntlet.HUDRui, "bestTime", BestRunTime );
		RuiSetFloat( CustomGauntlet.HUDRui, "enemiesMissedTimePenalty", MissedEnemiesPenalty );

		wait 4.0;
		CustomGauntlet_DestroyPlayerHUD();
	}
}

#endif

vector function Toolgun_Func_Gauntlet_GetPlaceLocation( entity player )
{
	vector eyePosition = player.EyePosition()
	vector viewVector = player.GetViewVector()
	TraceResults traceResults = TraceLine( eyePosition, eyePosition + viewVector * 10000, player, TRACE_MASK_PLAYERSOLID, TRACE_COLLISION_GROUP_PLAYER )
	return traceResults.endPos;
}

vector function Toolgun_Func_Gauntlet_GetSurfaceNormal( entity player )
{
	vector eyePosition = player.EyePosition()
	vector viewVector = player.GetViewVector()
	TraceResults traceResults = TraceLine( eyePosition, eyePosition + viewVector * 10000, player, TRACE_MASK_PLAYERSOLID, TRACE_COLLISION_GROUP_PLAYER )
	return traceResults.surfaceNormal;
}

vector function Toolgun_Func_Gauntlet_GetPlayerYaw( entity player )
{
	vector PlayerYaw = VectorToAngles( player.GetViewVector() );
	PlayerYaw.x = 0;
	PlayerYaw.z = 0;
	return PlayerYaw;
}

bool function Toolgun_Func_Gauntlet_PlaceStart( entity player, array<string> args )
{
#if CLIENT
	vector AimPos = Toolgun_Func_Gauntlet_GetPlaceLocation( player );
	vector PlayerYaw = Toolgun_Func_Gauntlet_GetPlayerYaw( player );
	CustomGauntlet_PlaceStartLine( AimPos + Vector(0, 0, 40), PlayerYaw );

	return true;
#else
	Toolgun_Utils_FireToolTracer( player );
	return false;
#endif
}

bool function Toolgun_Func_Gauntlet_PlaceFinish( entity player, array<string> args )
{
#if CLIENT
	vector AimPos = Toolgun_Func_Gauntlet_GetPlaceLocation( player );
	vector PlayerYaw = Toolgun_Func_Gauntlet_GetPlayerYaw( player );
	CustomGauntlet_PlaceFinishLine( AimPos + Vector(0, 0, 40), PlayerYaw );

	return true;
#else
	Toolgun_Utils_FireToolTracer( player );
	return false;
#endif
}

bool function Toolgun_Func_Gauntlet_PlaceTarget( entity player, array<string> args )
{
#if CLIENT
	vector AimPos = Toolgun_Func_Gauntlet_GetPlaceLocation( player );
	vector PlayerYaw = Toolgun_Func_Gauntlet_GetPlayerYaw( player );
	CustomGauntlet_PlaceTarget( AimPos + Vector(0, 0, 40), PlayerYaw );

	return true;
#else
	Toolgun_Utils_FireToolTracer( player );
	return false;
#endif
}

bool function Toolgun_Func_Gauntlet_PlaceLeaderboard( entity player, array<string> args )
{
#if CLIENT
	vector AimPos = Toolgun_Func_Gauntlet_GetPlaceLocation( player );
	vector SurfaceNormal = Toolgun_Func_Gauntlet_GetSurfaceNormal( player );
	vector Pos = AimPos + SurfaceNormal * 5.0;
	vector NormalAngs = VectorToAngles(SurfaceNormal) * -1;

	CustomGauntlet_PlaceLeaderboard( Pos, NormalAngs );

	return true;
#else
	Toolgun_Utils_FireToolTracer( player );
	return false;
#endif
}

bool function Toolgun_Func_Gauntlet_PlaceResults( entity player, array<string> args )
{
#if CLIENT
	vector AimPos = Toolgun_Func_Gauntlet_GetPlaceLocation( player );
	vector SurfaceNormal = Toolgun_Func_Gauntlet_GetSurfaceNormal( player );
	vector Pos = AimPos + SurfaceNormal * 5.0;
	vector NormalAngs = VectorToAngles(SurfaceNormal) * -1;

	CustomGauntlet_PlaceResults( Pos, NormalAngs );

	return true;
#else
	Toolgun_Utils_FireToolTracer( player );
	return false;
#endif
}


const array<asset> SpawnList = [
	$"models/angel_city/keypad_01.mdl",
	$"models/barriers/fence_wire_holder_double.mdl",
	$"models/beacon/beacon_crane_base_phys.mdl",
	$"models/beacon/beacon_crane_monitor.mdl",
	$"models/beacon/charge_generator_01_destroyed.mdl",
	$"models/beacon/charge_generator_01_glass.mdl",
	$"models/beacon/crane_room_monitor_console_static.mdl",
	$"models/beacon/kodai_fb_pipe_bracket_128.mdl",
	$"models/commercial/rack_spectre_wall.mdl",
	$"models/communication/terminal_usable_imc_01.mdl",
	$"models/containers/pelican_case_ammobox.mdl",
	$"models/dev/editor_ref.mdl",
	$"models/dev/empty_model.mdl",
	$"models/dev/empty_physics.mdl",
	$"models/dev/envballs.mdl",
	$"models/domestic/nessy_doll.mdl",
	$"models/domestic/nessy_mech_doll.mdl",
	$"models/foliage/bush_grassland_01.mdl",
	$"models/foliage/grass_golden_long_tall_01_animated.mdl",
	$"models/foliage/grass_golden_long_tall_03_animated.mdl",
	$"models/foliage/grass_green_long_01_animated.mdl",
	$"models/foliage/grass_green_long_02_animated.mdl",
	$"models/foliage/grass_green_long_03_animated.mdl",
	$"models/foliage/ground_plant_large_moss.mdl",
	$"models/foliage/leaves_ground_cherry_blossom_spread_01.mdl",
	$"models/foliage/tree_beacon_01.mdl",
	$"models/foliage/tree_beacon_02.mdl",
	$"models/foliage/tree_cherry_blossom_large_01.mdl",
	$"models/furniture/curved_bench_plastic.mdl",
	$"models/furniture/curved_bench_plastic_planter.mdl",
	$"models/fx/ar_holopulse.mdl",
	$"models/fx/ar_impact_pilot.mdl",
	$"models/fx/ar_marker_ringwobble.mdl",
	$"models/fx/cloak_cone_fx.mdl",
	$"models/fx/drone_frag_hex_glow_fx.mdl",
	$"models/fx/energy_connection_fx.mdl",
	$"models/fx/energy_proj_round.mdl",
	$"models/fx/energy_ring_core_fx.mdl",
	$"models/fx/energy_ring_edge.mdl",
	$"models/fx/energy_ring_fx.mdl",
	$"models/fx/frag_grenade_glow_fx.mdl",
	$"models/fx/hud_hex_shield_fx.mdl",
	$"models/fx/pilot_shield_wall.mdl",
	$"models/fx/pilot_shield_wall_01.mdl",
	$"models/fx/pilot_shield_wall_02.mdl",
	$"models/fx/pilot_shield_wall_03.mdl",
	$"models/fx/pilot_shield_wall_amped.mdl",
	$"models/fx/plasma_sphere_01.mdl",
	$"models/fx/screen_dmg_concussion.mdl",
	$"models/fx/titan_hex_gun_shield_edge.mdl",
	$"models/fx/titan_hex_gun_shield_fx.mdl",
	$"models/fx/turret_shield_wall.mdl",
	$"models/fx/turret_shield_wall_01.mdl",
	$"models/fx/turret_shield_wall_02.mdl",
	$"models/fx/turret_shield_wall_03.mdl",
	$"models/fx/vortex_shield_heat.mdl",
	$"models/fx/vortex_shield_heat2.mdl",
	$"models/fx/vortex_shield_heat_fp.mdl",
	$"models/fx/vortex_shield_hld.mdl",
	$"models/fx/vortex_shield_mod.mdl",
	$"models/fx/xo_emp_field.mdl",
	$"models/fx/xo_emp_field_inner.mdl",
	$"models/fx/xo_emp_field_inner_only.mdl",
	$"models/fx/xo_shield.mdl",
	$"models/fx/xo_shield_p1.mdl",
	$"models/fx/xo_shield_p2.mdl",
	$"models/fx/xo_shield_p4.mdl",
	$"models/fx/xo_shield_p5.mdl",
	$"models/fx/xo_shield_wall.mdl",
	$"models/fx/xo_shield_wall_01.mdl",
	$"models/fx/xo_shield_wall_02.mdl",
	$"models/fx/xo_shield_wall_03.mdl",
	$"models/fx/xo_shield__p3.mdl",
	$"models/fx/xo_sword_block.mdl",
	$"models/fx/xo_sword_block_hit.mdl",
	$"models/fx/xo_sword_block_prime.mdl",
	$"models/fx/xo_sword_hit_prime.mdl",
	$"models/gameplay/health_pickup_large.mdl",
	$"models/gameplay/health_pickup_small.mdl",
	$"models/gibs/human_gibs/gib_small_01.mdl",
	$"models/gibs/titan_gibs/at_gib1.mdl",
	$"models/gibs/titan_gibs/at_gib2.mdl",
	$"models/gibs/titan_gibs/at_gib3.mdl",
	$"models/gibs/titan_gibs/at_gib4.mdl",
	$"models/gibs/titan_gibs/at_gib5.mdl",
	$"models/gibs/titan_gibs/at_gib7_r_shin.mdl",
	$"models/gibs/titan_gibs/at_gib8_l_thigh1.mdl",
	$"models/gibs/titan_gibs/at_gib8_l_thigh2.mdl",
	$"models/gibs/titan_gibs/at_gib9_l_bicep1.mdl",
	$"models/gibs/titan_gibs/at_gib_hatch_d.mdl",
	$"models/gibs/titan_gibs/at_gib_l_arm1_d.mdl",
	$"models/gibs/titan_gibs/at_gib_l_arm2_d.mdl",
	$"models/gibs/titan_gibs/at_gib_r_arm1_d.mdl",
	$"models/gibs/titan_gibs/at_gib_r_arm2_d.mdl",
	$"models/gibs/titan_gibs/og_gib_r_forarm_d.mdl",
	$"models/gibs/glass_shard01.mdl",
	$"models/gibs/glass_shard02.mdl",
	$"models/gibs/glass_shard03.mdl",
	$"models/gibs/glass_shard04.mdl",
	$"models/gibs/glass_shard05.mdl",
	$"models/gibs/glass_shard06.mdl",
	$"models/gibs/human_gibs.mdl",
	$"models/gibs/metal_gib1.mdl",
	$"models/gibs/metal_gib2.mdl",
	$"models/gibs/metal_gib3.mdl",
	$"models/gibs/metal_gib4.mdl",
	$"models/gibs/metal_gib5.mdl",
	$"models/gibs/wood_gib01a.mdl",
	$"models/gibs/wood_gib01b.mdl",
	$"models/gibs/wood_gib01c.mdl",
	$"models/gibs/wood_gib01d.mdl",
	$"models/gibs/wood_gib01e.mdl",
	$"models/homestead/rock_cluster_basalt_01_halfwet_a.mdl",
	$"models/homestead/rock_cluster_basalt_01_halfwet_a_lg.mdl",
	$"models/homestead/rock_cluster_basalt_01_halfwet_a_sm.mdl",
	$"models/homestead/rock_cluster_basalt_01_halfwet_b.mdl",
	$"models/homestead/rock_cluster_basalt_01_halfwet_b_lg.mdl",
	$"models/homestead/rock_cluster_basalt_01_sm.mdl",
	$"models/homestead/rock_cluster_basalt_01_wet_sm.mdl",
	$"models/hud/grenade_indicator/grenade_indicator_arrow.mdl",
	$"models/hud/grenade_indicator/grenade_indicator_frag.mdl",
	$"models/hud/grenade_indicator/grenade_indicator_sonar.mdl",
	$"models/hud/grenade_indicator/grenade_indicator_tick.mdl",
	$"models/humans/grunts/grunt_specialist.mdl",
	$"models/humans/grunts/imc_grunt_lmg.mdl",
	$"models/humans/grunts/imc_grunt_lmg_helmet.mdl",
	$"models/humans/grunts/imc_grunt_rifle.mdl",
	$"models/humans/grunts/imc_grunt_shotgun.mdl",
	$"models/humans/grunts/imc_grunt_smg.mdl",
	$"models/humans/grunts/mlt_grunt_lmg.mdl",
	$"models/humans/grunts/mlt_grunt_rifle.mdl",
	$"models/humans/grunts/mlt_grunt_shotgun.mdl",
	$"models/humans/grunts/mlt_grunt_smg.mdl",
	$"models/humans/heroes/mlt_hero_anderson.mdl",
	$"models/humans/heroes/mlt_hero_anderson_helmet.mdl",
	$"models/humans/heroes/mlt_hero_jack.mdl",
	$"models/humans/heroes/mlt_hero_jack_helmet_static.mdl",
	$"models/humans/heroes/mlt_hero_lastimosa.mdl",
	$"models/humans/imc_pilot/male_br/imc_pilot_male_br_helmet_dam1a.mdl",
	$"models/humans/imc_pilot/male_br/imc_pilot_male_br_helmet_dam1b.mdl",
	$"models/humans/imc_pilot/male_br/imc_pilot_male_br_helmet_dam1c.mdl",
	$"models/humans/imc_pilot/male_br/imc_pilot_male_br_helmet_dam1d.mdl",
	$"models/humans/pete/human_male_anims_workspace.mdl",
	$"models/humans/pete/pete_agents.mdl",
	$"models/humans/pete/pete_core.mdl",
	$"models/humans/pete/pete_menu.mdl",
	$"models/humans/pete/pete_poses.mdl",
	$"models/humans/pete/pete_reactions.mdl",
	$"models/humans/pete/pete_scripted.mdl",
	$"models/humans/pete/pete_scripted_beacon.mdl",
	$"models/humans/pete/pete_scripted_boss_intros.mdl",
	$"models/humans/pete/pete_scripted_intro.mdl",
	$"models/humans/pete/pete_scripted_r1.mdl",
	$"models/humans/pete/pete_scripted_sewers.mdl",
	$"models/humans/pete/pete_scripted_ship2ship.mdl",
	$"models/humans/pete/pete_scripted_skyway.mdl",
	$"models/humans/pete/pete_scripted_timeshift.mdl",
	$"models/humans/pete/pete_scripted_wilds.mdl",
	$"models/humans/pete/pete_skits.mdl",
	$"models/humans/pete/pilot_shared.mdl",
	$"models/humans/pilots/pilot_light_ged_m_head_gib.mdl",
	$"models/humans/pilots/pilot_medium_reaper_f.mdl",
	$"models/humans/pilots/sp_medium_geist_f.mdl",
	$"models/humans/pilots/sp_medium_reaper_m.mdl",
	$"models/industrial/bolt_tiny01.mdl",
	$"models/industrial/grappling_hook_end.mdl",
	$"models/industrial/safety_baton.mdl",
	$"models/lamps/exterior_walkway_light.mdl",
	$"models/lamps/office_lights_hanging_wire.mdl",
	$"models/levels_terrain/mp_wargames/wargames_grid_square_black.mdl",
	$"models/levels_terrain/sp_training/sp_training_block_clump_01.mdl",
	$"models/levels_terrain/sp_training/sp_training_block_clump_02.mdl",
	$"models/levels_terrain/sp_training/sp_training_block_clump_03.mdl",
	$"models/levels_terrain/sp_training/sp_training_block_clump_04.mdl",
	$"models/levels_terrain/sp_training/sp_training_block_single_01.mdl",
	$"models/levels_terrain/sp_training/sp_training_mac_godrays_01.mdl",
	$"models/levels_terrain/sp_training/vr_training_godrays.mdl",
	$"models/mcor/mcor_cabinet_console_01.mdl",
	$"models/mcor/mcor_cage_lift_01.mdl",
	$"models/mcor/mcor_chair_01.mdl",
	$"models/mcor/mcor_corner_consoles_64.mdl",
	$"models/mcor/mcor_desk_console_01.mdl",
	$"models/mcor/mcor_fan_casing_01.mdl",
	$"models/mcor/mcor_monitor_01.mdl",
	$"models/mcor/mcor_monitor_rack_02.mdl",
	$"models/mcor/mcor_monitor_rack_03.mdl",
	$"models/mcor/mcor_monitor_rack_05.mdl",
	$"models/mcor/mcor_monitor_rack_06.mdl",
	$"models/mcor/mcor_monitor_rack_07.mdl",
	$"models/mendoko/pipe_modular_mendoko_128.mdl",
	$"models/mendoko/pipe_modular_mendoko_16.mdl",
	$"models/mendoko/pipe_modular_mendoko_32.mdl",
	$"models/mendoko/pipe_modular_mendoko_32_tjunk.mdl",
	$"models/mendoko/pipe_modular_mendoko_32_valve.mdl",
	$"models/mendoko/pipe_modular_mendoko_64.mdl",
	$"models/mendoko/pipe_modular_mendoko_8.mdl",
	$"models/mendoko/pipe_modular_mendoko_corner.mdl",
	$"models/mendoko/pipe_modular_mendoko_metal_64.mdl",
	$"models/metal_scraps/scrap_metal03.mdl",
	$"models/metal_scraps/scrap_metal04.mdl",
	$"models/ola/sewer_staircase_quad.mdl",
	$"models/pipes/pipe_modular_grey_bracket_cap.mdl",
	$"models/props/titan_battery_static/titan_battery_static.mdl",
	$"models/props/titan_rack/titan_rack_v2.mdl",
	$"models/props_debris/concrete_chunk02a.mdl",
	$"models/props_debris/concrete_chunk03a.mdl",
	$"models/props_debris/concrete_chunk07a.mdl",
	$"models/props_debris/concrete_chunk08a.mdl",
	$"models/props_debris/concrete_chunk09a.mdl",
	$"models/robotics_r2/turret_plasma/plasma_turret_pc_1.mdl",
	$"models/robotics_r2/turret_plasma/plasma_turret_pc_2.mdl",
	$"models/robotics_r2/turret_plasma/plasma_turret_pc_3.mdl",
	$"models/robots/aerial_unmanned_worker/worker_drone_pc1.mdl",
	$"models/robots/aerial_unmanned_worker/worker_drone_pc2.mdl",
	$"models/robots/aerial_unmanned_worker/worker_drone_pc3.mdl",
	$"models/robots/aerial_unmanned_worker/worker_drone_pc4.mdl",
	$"models/robots/agp/agp_hemlok_larger.mdl",
	$"models/robots/drone_air_attack/drone_air_attack_plasma.mdl",
	$"models/robots/drone_air_attack/drone_air_attack_rockets.mdl",
	$"models/robots/drone_air_attack/drone_attack_pc_1.mdl",
	$"models/robots/drone_air_attack/drone_attack_pc_2.mdl",
	$"models/robots/drone_air_attack/drone_attack_pc_3.mdl",
	$"models/robots/drone_air_attack/drone_attack_pc_4.mdl",
	$"models/robots/drone_air_attack/drone_attack_pc_5.mdl",
	$"models/robots/drone_frag/drone_frag.mdl",
	$"models/robots/marvin/marvin.mdl",
	$"models/robots/marvin/marvin_anims.mdl",
	$"models/robots/spectre/spectre_assault_d_gib_arm_l.mdl",
	$"models/robots/spectre/spectre_assault_d_gib_arm_r.mdl",
	$"models/robots/spectre/spectre_assault_d_gib_leg_l.mdl",
	$"models/robots/spectre/spectre_assault_d_gib_leg_r.mdl",
	$"models/robots/super_spectre/sup_spectre_chest_l.mdl",
	$"models/robots/super_spectre/sup_spectre_chest_mf.mdl",
	$"models/robots/super_spectre/sup_spectre_chest_mr.mdl",
	$"models/robots/super_spectre/sup_spectre_chest_r.mdl",
	$"models/rocks/fract_chunk_small_03.mdl",
	$"models/rocks/rock_horizontal_01_white.mdl",
	$"models/rocks/rock_horizontal_02_white.mdl",
	$"models/rocks/rock_small_02.mdl",
	$"models/s2s/s2s_railing_small_01_128.mdl",
	$"models/s2s/s2s_railing_small_01_32.mdl",
	$"models/s2s/s2s_railing_small_01_64.mdl",
	$"models/s2s/s2s_stair_railing_small_end_01.mdl",
	$"models/s2s/s2s_wall_light_01.mdl",
	$"models/sandtrap/sandtrap_wall_bracket.mdl",
	$"models/sewers/sewer_wire_black_set_thick_01.mdl",
	$"models/sewers/sewer_wire_black_set_thick_02.mdl",
	$"models/sewers/sewer_wire_black_set_thick_04.mdl",
	$"models/statues/lion_statue_bronze_green_small.mdl",
	$"models/test/brad/store_card.mdl",
	$"models/test/brad/store_card_angel_city.mdl",
	$"models/test/brad/store_card_colony.mdl",
	$"models/test/brad/store_card_prime_bundle.mdl",
	$"models/test/brad/store_card_relic.mdl",
	$"models/test/brad/store_titan_warpaint_bundle.mdl",
	$"models/test/brad/store_weapon_warpaint_bundle.mdl",
	$"models/thaw/roof_generator_ac.mdl",
	$"models/titans/buddy/bt_posed.mdl",
	$"models/titans/buddy/titan_buddy.mdl",
	$"models/titans/buddy/titan_buddy_anims_workspace.mdl",
	$"models/titans/buddy/titan_buddy_embark.mdl",
	$"models/titans/buddy/titan_buddy_melee.mdl",
	$"models/titans/buddy/titan_buddy_mp_core.mdl",
	$"models/titans/buddy/titan_buddy_reactions.mdl",
	$"models/titans/buddy/titan_buddy_scripted.mdl",
	$"models/titans/buddy/titan_buddy_scripted_beacon.mdl",
	$"models/titans/buddy/titan_buddy_scripted_s2s.mdl",
	$"models/titans/buddy/titan_buddy_scripted_timeshift.mdl",
	$"models/titans/buddy/titan_buddy_scripted_wilds.mdl",
	$"models/titans/buddy/titan_buddy_sp_core.mdl",
	$"models/titans/medium/sp_titan_medium_ajax.mdl",
	$"models/titans/medium/titan_medium_anims_workspace.mdl",
	$"models/titans/medium/titan_medium_battery_static.mdl",
	$"models/titans/medium/titan_medium_mp_core.mdl",
	$"models/titans/medium/titan_medium_mp_embark.mdl",
	$"models/titans/medium/titan_medium_mp_hotdrop_ajax.mdl",
	$"models/titans/medium/titan_medium_mp_melee.mdl",
	$"models/titans/medium/titan_medium_mp_reactions.mdl",
	$"models/titans/medium/titan_medium_mp_scripted.mdl",
	$"models/titans/medium/titan_medium_mp_synced.mdl",
	$"models/titans/medium/titan_medium_sp_core.mdl",
	$"models/training/sp_training_tree_01.mdl",
	$"models/training/sp_training_tree_02.mdl",
	$"models/training/sp_training_tree_03.mdl",
	$"models/training/sp_training_wood_gunrack_01.mdl",
	$"models/utilities/wire_ceiling_mounts_straight.mdl",
	$"models/vehicle/crow_dropship/crow_dropship_afterburner1.mdl",
	$"models/vehicle/crow_dropship/crow_dropship_afterburner2.mdl",
	$"models/vehicle/crow_dropship/crow_dropship_dest_l_wing.mdl",
	$"models/vehicle/crow_dropship/crow_dropship_dest_nose.mdl",
	$"models/vehicle/crow_dropship/crow_dropship_dest_r_wing.mdl",
	$"models/vehicle/draconis/draconis_back_eng_glow.mdl",
	$"models/vehicle/draconis/draconis_box_thruster_glow.mdl",
	$"models/vehicle/draconis/draconis_side_eng_glow.mdl",
	$"models/vehicle/droppod_fireteam/droppod_fireteam_arm.mdl",
	$"models/vehicle/droppod_fireteam/droppod_fireteam_door.mdl",
	$"models/vehicle/dropship/dropship_afterburner.mdl",
	$"models/vehicle/dropship/dropship_common.mdl",
	$"models/vehicle/goblin_dropship/goblin_dropship.mdl",
	$"models/vehicle/goblin_dropship/goblin_dropship_debris_01.mdl",
	$"models/vehicle/goblin_dropship/goblin_dropship_debris_03.mdl",
	$"models/vehicle/hornet/hornet_fighter_afterburner1.mdl",
	$"models/vehicle/hornet/hornet_fighter_dest_l_wing.mdl",
	$"models/vehicle/hornet/hornet_fighter_dest_nose.mdl",
	$"models/vehicle/hornet/hornet_fighter_dest_r_wing.mdl",
	$"models/vehicle/straton/straton_imc_gunship_afterburner.mdl",
	$"models/vistas/s2s_sky2.mdl",
	$"models/vistas/train_r2_sky.mdl",
	$"models/weapons/alternator_smg/ptpov_alternator_smg.mdl",
	$"models/weapons/alternator_smg/w_alternator_smg.mdl",
	$"models/weapons/alternator_smg/w_alternator_smg_stow.mdl",
	$"models/weapons/ammoboxes/ammobox_01.mdl",
	$"models/weapons/ammoboxes/backpack_single.mdl",
	$"models/weapons/arms/buddypov.mdl",
	$"models/weapons/arms/human_pov_cockpit.mdl",
	$"models/weapons/arms/petepov_workspace.mdl",
	$"models/weapons/arms/pov_mlt_hero_jack_rifleman.mdl",
	$"models/weapons/arms/pov_pete_core.mdl",
	$"models/weapons/arms/pov_titan_medium_cockpit.mdl",
	$"models/weapons/atpov_titan_sniper_rifle/atpov_titan_sniper_rifle.mdl",
	$"models/weapons/at_rifle/ptpov_at_rifle.mdl",
	$"models/weapons/at_rifle/w_at_rifle.mdl",
	$"models/weapons/b3wing/ptpov_b3wing.mdl",
	$"models/weapons/b3wing/w_b3wing.mdl",
	$"models/weapons/bullets/bullet_rifle.mdl",
	$"models/weapons/bullets/damage_arrow.mdl",
	$"models/weapons/bullets/mgl_grenade.mdl",
	$"models/weapons/bullets/projectile_20mm.mdl",
	$"models/weapons/bullets/projectile_40mm.mdl",
	$"models/weapons/bullets/projectile_arc_ball.mdl",
	$"models/weapons/bullets/projectile_arl.mdl",
	$"models/weapons/bullets/projectile_rocket.mdl",
	$"models/weapons/bullets/projectile_rocket_large.mdl",
	$"models/weapons/bullets/projectile_rocket_largest.mdl",
	$"models/weapons/bullets/projectile_rocket_launcher_sram.mdl",
	$"models/weapons/bullets/projectile_shotgun.mdl",
	$"models/weapons/bullets/temp_triple_threat_projectile_large.mdl",
	$"models/weapons/bullets/triple_threat_projectile.mdl",
	$"models/weapons/bullets/triple_threat_projectile_open.mdl",
	$"models/weapons/caber_shot/caber_shot_tether_xl.mdl",
	$"models/weapons/caber_shot/caber_shot_thrown.mdl",
	$"models/weapons/caber_shot/caber_shot_thrown_xl.mdl",
	$"models/weapons/caber_shot/fx_caber_shot_thrown_glow.mdl",
	$"models/weapons/car101/ptpov_car101.mdl",
	$"models/weapons/car101/w_car101.mdl",
	$"models/weapons/data_knife/v_data_knife.mdl",
	$"models/weapons/empty_handed/atpov_emptyhand.mdl",
	$"models/weapons/empty_handed/atpov_emptyhand_flamewall.mdl",
	$"models/weapons/empty_handed/atpov_emptyhand_flamewave.mdl",
	$"models/weapons/empty_handed/atpov_laser_cannon.mdl",
	$"models/weapons/empty_handed/ptpov_emptyhand.mdl",
	$"models/weapons/empty_handed/w_empty_handed_human.mdl",
	$"models/weapons/empty_handed/w_empty_handed_titan.mdl",
	$"models/weapons/empty_handed/w_laser_cannon.mdl",
	$"models/weapons/epg/ptpov_epg.mdl",
	$"models/weapons/epg/w_epg.mdl",
	$"models/weapons/g2/ptpov_g2a4.mdl",
	$"models/weapons/g2/w_g2a4.mdl",
	$"models/weapons/grenades/arc_grenade.mdl",
	$"models/weapons/grenades/arc_grenade_projectile.mdl",
	$"models/weapons/grenades/m20_f_grenade.mdl",
	$"models/weapons/grenades/m20_f_grenade_projectile.mdl",
	$"models/weapons/grenades/ptpov_frag_grenade.mdl",
	$"models/weapons/grenades/ptpov_sentry_frag.mdl",
	$"models/weapons/grenades/smoke_grenade_projectile.mdl",
	$"models/weapons/hemlock_br/ptpov_hemlock_br.mdl",
	$"models/weapons/hemlock_br/w_hemlock_br.mdl",
	$"models/weapons/hemlok_smg/ptpov_hemlok_smg.mdl",
	$"models/weapons/hemlok_smg/w_hemlok_smg.mdl",
	$"models/weapons/kunai/w_kunai_projectile.mdl",
	$"models/weapons/lmg_hemlok/ptpov_lmg_hemlok.mdl",
	$"models/weapons/lmg_hemlok/w_lmg_hemlok.mdl",
	$"models/weapons/lstar/ptpov_lstar.mdl",
	$"models/weapons/lstar/ptpov_lstar_menu.mdl",
	$"models/weapons/lstar/w_lstar.mdl",
	$"models/weapons/lstar/w_lstar_stow.mdl",
	$"models/weapons/m1a1_hemlok/ptpov_hemlok.mdl",
	$"models/weapons/m1a1_hemlok/w_hemlok.mdl",
	$"models/weapons/mastiff_stgn/ptpov_mastiff.mdl",
	$"models/weapons/mastiff_stgn/ptpov_mastiff_menu.mdl",
	$"models/weapons/mastiff_stgn/w_mastiff.mdl",
	$"models/weapons/p2011/ptpov_p2011.mdl",
	$"models/weapons/p2011/w_p2011.mdl",
	$"models/weapons/p2011_auto/ptpov_p2011_auto.mdl",
	$"models/weapons/p2011_auto/w_p2011_auto.mdl",
	$"models/weapons/projectiles/projectile_grapple_hook_anchor_bolt.mdl",
	$"models/weapons/rspn101/ptpov_rspn101.mdl",
	$"models/weapons/rspn101/w_rspn101.mdl",
	$"models/weapons/rspn101/w_rspn101_stow.mdl",
	$"models/weapons/rspn101_dmr/ptpov_rspn101_dmr.mdl",
	$"models/weapons/rspn101_dmr/w_rspn101_dmr.mdl",
	$"models/weapons/sentry_frag/sentry_frag.mdl",
	$"models/weapons/sentry_frag/sentry_frag_proj.mdl",
	$"models/weapons/sentry_shield/sentry_shield_proj.mdl",
	$"models/weapons/sentry_shield/sentry_shield_proj_hack.mdl",
	$"models/weapons/shellejects/shelleject_20mm.mdl",
	$"models/weapons/shellejects/shelleject_40mm.mdl",
	$"models/weapons/shellejects/shelleject_assault_rifle.mdl",
	$"models/weapons/shellejects/shelleject_large_rifle.mdl",
	$"models/weapons/shellejects/shelleject_pistol.mdl",
	$"models/weapons/shellejects/shelleject_shotshell.mdl",
	$"models/weapons/shoulder_rocket_sram/ptpov_law.mdl",
	$"models/weapons/shoulder_rocket_sram/ptpov_law_menu.mdl",
	$"models/weapons/shoulder_rocket_sram/w_rocket_sram_v2_stow.mdl",
	$"models/weapons/shoulder_rocket_sram/w_shoulder_rocket_sram_v2.mdl",
	$"models/weapons/softball_at/ptpov_softball_at_menu.mdl",
	$"models/weapons/thr_40mm/atpov_thr_40mm.mdl",
	$"models/weapons/thr_40mm/w_thr_40mm.mdl",
	$"models/weapons/titan_bt_rocket_pod/atpov_titan_bt_laser_pod.mdl",
	$"models/weapons/titan_bt_rocket_pod/atpov_titan_bt_rocket_pod.mdl",
	$"models/weapons/titan_bt_rocket_pod/atpov_titan_bt_rocket_pod_core.mdl",
	$"models/weapons/titan_bt_rocket_pod/atpov_titan_bt_rocket_pod_right.mdl",
	$"models/weapons/titan_incendiary_trap/w_titan_incendiary_trap.mdl",
	$"models/weapons/titan_particle_accelerator/atpov_titan_particle_accelerator.mdl",
	$"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl",
	$"models/weapons/titan_predator/atpov_titan_predator.mdl",
	$"models/weapons/titan_predator/titan_predator_barrel_blur.mdl",
	$"models/weapons/titan_predator/titan_predator_barrel_charge.mdl",
	$"models/weapons/titan_predator/titan_predator_barrel_glow.mdl",
	$"models/weapons/titan_predator/titan_predator_barrel_hot.mdl",
	$"models/weapons/titan_predator/w_titan_predator.mdl",
	$"models/weapons/titan_raptor_rocket_pod/atpov_titan_raptor_rocket_pod_core.mdl",
	$"models/weapons/titan_raptor_rocket_pod/atpov_titan_raptor_rocket_pod_right.mdl",
	$"models/weapons/titan_rocket_launcher/atpov_titan_rocket_launcher.mdl",
	$"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl",
	$"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl",
	$"models/weapons/titan_sword/atpov_titan_sword.mdl",
	$"models/weapons/titan_sword/atpov_titan_sword_block.mdl",
	$"models/weapons/titan_sword/atpov_titan_sword_emp_wave.mdl",
	$"models/weapons/titan_sword/atpov_titan_sword_prime.mdl",
	$"models/weapons/titan_sword/atpov_titan_sword_prime_block.mdl",
	$"models/weapons/titan_sword/atpov_titan_sword_prime_emp_wave.mdl",
	$"models/weapons/titan_sword/w_titan_sword.mdl",
	$"models/weapons/titan_sword/w_titan_sword_prime.mdl",
	$"models/weapons/titan_sword/w_titan_sword_static.mdl",
	$"models/weapons/titan_thermite_launcher/atpov_titan_thermite_launcher.mdl",
	$"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl",
	$"models/weapons/titan_triple_threat/atpov_titan_triple_threat.mdl",
	$"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl",
	$"models/weapons/titan_trip_wire/titan_trip_wire.mdl",
	$"models/weapons/titan_trip_wire/titan_trip_wire_projectile.mdl",
	$"models/weapons/titan_vortex_blocker/atpov_vortexblocker.mdl",
	$"models/weapons/titan_vortex_blocker/atpov_vortexblocker_scorch.mdl",
	$"models/weapons/titan_vortex_blocker/w_vortexblocker.mdl",
	$"models/weapons/titan_xo16_shorty/atpov_xo16shorty.mdl",
	$"models/weapons/titan_xo16_shorty/atpov_xo16shorty_offhand.mdl",
	$"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl",
	$"models/weapons/training_pod/training_pod.mdl",
	$"models/weapons/vinson/ptpov_vinson.mdl",
	$"models/weapons/vinson/w_vinson.mdl",
	$"models/weapons/w1128/ptpov_w1128.mdl",
	$"models/weapons/w1128/w_w1128.mdl",
	$"models/error.mdl",
];
